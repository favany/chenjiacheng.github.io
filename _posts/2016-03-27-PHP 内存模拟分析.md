---
layout: post
categories: PHP
tags: [PHP]
---

**值传递：**将一个变量的值，复制一份，把新的这份交给另外一个变量保存，从而在内存中产生两个变量，对应两个不同的值，任何一个的修改都不会影响彼此。

```
$变量1 = 值;
$变量2 = $变量1;
```

**引用传值：**变量实际保存的是数据对应的内存地址，如果将一个变量所保存的内存地址赋值给另外一个变量，存在两个变量共同指向同一块内存地址，一个变量的修改会导致另外一个变量的修改。引用传递必须在被传递的变量之前使用地址符号：`&`

```
$变量1 = 值;
$变量2 = &$变量1; // 取$变量1的地址
```

## 内存分析

内存都是分为以下几个部分：

* 栈区：是程序所能操作的理论上唯一的内存区域，内存很小，但是效率最高。
* 堆区：是唯一的内存地址连续的内存，内存很大，但是效率最低。
* 代码段：装载代码的内存，程序要运行，必须先将代码装载到代码段，然后在代码段里面逐行的运行程序代码。
* 数据段：是普通数据存储的内存，里面通常还分为两块区域: 全局区存放普通数据；静态区存储常量和静态数据。

![01.png](/static/images/20160327/01.png)

> 在内存中，程序所能操作的只有栈区，数据段和堆区都是由栈区来操作

## PHP 代码的执行

PHP 是一种高级语言（接近自然语言），所以不可能被计算机直接解析（计算机只能识别机器码（二进制））。

1. 将所有的脚本（代码）加载到内存（代码段）
2. 编译（词法分析、语法分析）
3. 生成opcode：机器可以执行的代码（二进制）
4. zendEngine（zend引擎）解析 opcode，返回执行结果 

![02.png](/static/images/20160327/02.png)

## PHP 代码内存分析

1. 将代码加载到代码段：编译
2. 逐行的执行代码
3. PHP 将执行结束的结果返回

**举个例子**

```
// 定义变量
$f = 1;
$s = $f; // 值传递
$t = &$f; // 引用传递

const PI = 3.14;

// 修改变量
$s = 2;
$t = 3;

// 输出
echo $f, $s, $t;
```

**1. 加载源代码：编译（对代码进行优化）将代码加载到代码段**

![03.png](/static/images/20160327/03.png)

**2. 执行代码**

2.1 执行 `$f = 1;`

① 在栈区开辟空间存储 `$f`

② 在全局区开辟内存存储数据 `1`

③ 将 `1` 所在内存地址赋值给 `$f` 变量

![04.png](/static/images/20160327/04.png)

2.2 执行 `$s = $f;`

① 在栈区开辟空间存储 `$s`

② 取得 `$f` 所存储地内存地址里面保存的数据 `1`

③ 在全局区开辟一块新的内存地址保存值 `1`

④ 将新的值 `1` 的内存地址赋值给 `$t`

![05.png](/static/images/20160327/05.png)

2.3 执行 `$t = &$f;`

① 在栈区开辟空间存储 `$t`

② 获取 `$f` 所存储的内存地址

③ 将取出来的内存地址赋值给 `$t`

![06.png](/static/images/20160327/06.png)

2.4 执行 `const PI = 3.14;`

① 在栈区开辟空间保存 `PI`

② 在静态区开辟内存存储 `3.14`

③ 将 `3.14` 的内存地址赋值给 `PI`


![07.png](/static/images/20160327/07.png)

2.5 执行 `$s = 2;`

① 找到 `$s`变量所指向的内存地址

② 修改原来的值为 `2`

![08.png](/static/images/20160327/08.png)

2.6 执行 `$t = 3;`

① 找到 `$t` 变量所指向的内存地址

② 修改原来的值为 `3`

![09.png](/static/images/20160327/09.png)

2.7 执行 `echo $f, $s, $t;`

通过变量找到内存地址，取出里面的值并输出：`3,2,3`

**3. 脚本执行结束：释放所有的内存（栈区和代码段）**

3.1 代码段自动释放

![10.png](/static/images/20160327/10.png)

3.2 释放所有程序内存（栈区）

![11.png](/static/images/20160327/11.png)

3.3 操作系统回收内存：凡是没有被引用的全部回收

![12.png](/static/images/20160327/12.png)

> 总结：当程序在执行中会占用内存，执行完毕后，内存全部被回收。