---
layout: post
categories: 计算机组成原理
tags: [计算机组成原理]
---

## 进位计数值

* r 进制数：基数 = r 每个数码位可能出现 r 种字符。逢 r 进 1
* r 进制数 -> 十进制：r 进制数的数值 = 各数码位与位权的乘积之和

* 二进制 <-> 八进制：每 3 个二进制位对应一个八进制位
* 二进制 <-> 十六进制：每 4 个二进制位对应一个十六进制位
* 十进制 -> r 进制
  * 整数部分：除基取余法，先取得的 “余” 是整数的低位
  * 小数部分：乘基取整法，先取得的 “整” 是小数的高价
* 真值和机器数
  * 真值：实际的带正负号的数值（人类习惯的样子）
  * 机器数：把正负号数字化的数（存到机器里的样子）

## BCD 码

* 8421 码
  * 每 4 个二进制位对应一个十进制位（有6个冗余状态）
  * 8、4、2、1分别对应每一位的权值
  * 0000~1001 分别对应 0~9，进行加法后若超出该范围，则需 +0110 进行修正（强制向高位进 1）
* 余 3 码：8421 码 + (0011)
* 2421 码：
  * 2、4、2、1 分别对应每一位的权值
  * 表示 0~4 时最高位为 0，表示 5~9 时最高位为 1

## 字符与字符串

* ASCII 码
  * 通常用 8bit 表示一个字符，最高位都为 0
  * 共 128 个字符。0~31、127 为控制/通信字符；32~126 为可印刷字符
  * 所有大写字母、所有小写字母、所有数字的编码都连续
* 汉字
  * 区位码、国标码、汉字内码、输入编码、字形码
  * 国标码 = 区位码 + 2020H
  * 机内码 = 国标码 + 8080H
* 字符串
  * 从低地址到高地址逐个字符存储，常采用 "0 作为结尾标志
  * 对于多字节的数据（如汉字），可采取大/小端存储模式
  * 大端模式：将数据的最高有效字节存放在低地址单元中
  * 小端模式：将数据的最高有效字节存放在高地址单元中

## 奇偶检验

* 校验原理
  * 码字间的距离：两个码字之间有几个位不同
  * 码距：一个编码方案中，合法码字间的最小距离	
  * 若码距=2，有检错能力；若码距≥3，可能还会纠错能力
* 奇偶校验
  * 在信息位的首部或尾部添加一个奇偶校验位
  * 奇校验：整个校验码（信息位和校验位）中 “1” 的个数为奇数
  * 偶校验：整个校验码（信息位和校验位）中 “1” 的个数为偶数
  * 奇偶校验码的码距 d=2，仅能检测出奇数位错误，无纠错能力
* 异或运算（模二加）：两个比特进行异或运算，仅当二者不同时计算结果为 1

## 海明码

* 基本思想：分组偶校验，多个校验位可反映出错位置
* 求解步骤
  * 确定校验位个数（k 个校验位，n 个信息位）
  * 确定校验位分布
    * P1，P2，P3...分别在 1，2，4，8，16...
    * 空出来的其他位置依次填入信息位
  * 求校验位
    * 将信息位的位置序号用 k 位二进制数表示出来
    * 校验位 Pi 与位置序号第 i 位为 1 的信息位归为同一组，进行偶校验
  * 纠错
    * 对 P1，P2，P3...所属各分组进行异或（相当于分组偶校验）求得 S1，S2，S3...
    * S3 S2 S1 = 000，说明无错误
    * S3 S2 S1 ≠ 000，则其值反映出错位置
* 补充
  * 海明码有 1 位纠错，2 位检错能力
  * 为了区分 1 位错和 2 位错，还需添加 “全校验位” 对整体进行偶校验	
  * 注意有的题目位置编号可能是从小到大的，但处理方法雷同

## 循环冗余检验码

* 构造
  * 由生成多项式确定 “除数”。若生成多项式中 x 的最高次为 R，则 “除数” 有 R+1 位
  * K 个信息位 +R 个 0 作为 “被除数”
  * 被除数、除数进行 “模二除”，得 R 位余数
  * K 个信息位 +R 位余数 = CRC 码
* 校验
  * 收到 K+R 位数据，与生成多项式模二除，计算 R 位余数
  * 余数为 0，说明无错误	
  * 余数非 0，说明出错
* 检错、纠错能力
  * 可检测出所有奇数个错误;
  * 可检测出所有双比特的错误;
  * 可检测出所有小于等于校验位长度的连续错误;
  * 若选择合适的生成多项式，且 2^R ≥ K+R+1 则可纠正单比特错

## 定点数移位运算

* 算数移位
  * 左移 1 位相当于 x 基数；右移移位相当于 ÷ 基数
  * 原码：符号位不参与移位。左移、右移都补 0
  * 反码：符号位不参与移位。左移、右移都补 0
  * 补码
    * 负数补码最右边的 1 及其右边与原码相同最右边的 1 的左边与反码相同
    * 符号位不参与移位。左移补 0，右移补 1
* 逻辑移位：左移、右移都补 0，移出的位舍弃
* 循环移位
  * 不带进位位：用移出的位补上空缺
  * 带进位位：移出的位放到进位位，原进位位补上空缺

## 加减运算

* 原码
  * 加法
    * 同号相加
      * 数值部分 = 被加数、加数的绝对值进行相加
      * 符号位不变
    * 异号相加
      * 数值部分 = 被加数、加数中，绝对值更大的减绝对值更小的
      * 符号位与绝对值更大的数相同
  * 减法
    * 将减数取负，转变为加法
* 补码：总是要转变成加法，符号位参与运算
* 溢出判断（补码）
  * Key：正+正=负(上溢)；负+负=正(下溢)
  * 方法三：采用双符号位，正数符号为 00，负数符号为 11，加法运算后若双符号位 =01 则发生上溢；若双符号位 =10 则发生下溢，若两个符号位相同则未发生溢出
* 符号扩展
  * 定点整数的符号扩展：在原符号位和数值位中间添加新位，正数都添 0；负数原码添 0，负数反、补码添 1
  * 定点小数的符号扩展:在原符号位和数值位后面添加新位，正数都添 0；负数原、补码添 0 负数反码添 1