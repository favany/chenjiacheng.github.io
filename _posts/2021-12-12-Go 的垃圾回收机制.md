---
layout: post
categories: Go
tags: [Go基础]
---

通常 PHP/C++ 通过指针引用计数来回收对象，但是这不能处理循环引用。为了避免引用计数的缺陷，后来出现了标记清除，分代等垃圾回收算法。Go 的垃圾回收官方形容为 **非分代 非紧缩 写屏障 并发标记清理**。标记清理算法的字面解释，就是将可达的内存块进行标记 mark，最后没有标记的不可达内存块将进行清理 sweep。

## 常见的垃圾回收算法

- 引用计数：每个对象维护一个引用计数，当被引用对象被创建或被赋值给其他对象时引用计数自动加 +1；如果这个对象被销毁，则计数 -1 ，当计数为 0 时，回收该对象。
  - 优点：对象可以很快被回收，不会出现内存耗尽或到达阀值才回收。
  - 缺点：不能很好的处理循环引用
- 标记-清除：从根变量开始遍历所有引用的对象，引用的对象标记 “被引用”，没有被标记的则进行回收。
  - 优点：解决了引用计数的缺点。
  - 缺点：需要 STW（stop the world），暂时停止程序运行。
- 分代收集：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，短的放入新生代，不同代有不同的回收算法和回收频率。
  - 优点：回收性能好
  - 缺点：算法复杂

## 三色标记法

三色标记法（tricolor mark-and-sweep algorithm）是传统 Mark-Sweep 的一个改进，它是一个并发的 GC 算法，在 Golang 中被用作垃圾回收的算法，但是也会有一个缺陷，可能程序中的垃圾产生的速度会大于垃圾收集的速度，这样会导致程序中的垃圾越来越多无法被收集掉。原理如下所示：

1. 初始状态下所有对象都是白色的。
2. 从根节点开始遍历所有对象，把遍历到的对象变成灰色对象
3. 遍历灰色对象，将灰色对象引用的对象也变成灰色对象，然后将遍历过的灰色对象变成黑色对象。
4. 循环步骤3，直到灰色对象全部变黑色。
5. 通过写屏障(write-barrier)检测对象有变化，重复以上操作
6. 收集所有白色对象（垃圾）。

也可以参考下面的动图辅助理解：

![01.awebp](/static/images/20211212/01.awebp)

> 为了避免GC的过程中新修改的引用关系到GC的结果发生错误，我们需要进行STW（Stop The World，停止所有正在运行的协程）。但是STW会影响程序的性能（尽管Golang目前已经可以做到1ms以下的STW），所以我们要通过写屏障技术尽可能地缩短STW的时间。
>
> 写屏障(Write Barrier)：该屏障之前的写操作和之后的写操作相比，先被系统其它组件感知。 好难懂哦，结合上面GC工作的完整流程就好理解了，就是在每一轮GC开始时会初始化一个叫做“屏障”的东西，然后由它记录第一次scan时各个对象的状态，以便和第二次re-scan进行比对，引用状态变化的对象被标记为灰色以防止丢失，将屏障前后状态未变化对象继续处理。

## GC 触发条件

**主动触发：**调用 runtime.GC 

**被动触发：**

自动垃圾回收的触发条件有两个：

1. 超过内存大小阈值
2. 达到定时时间

阈值是由一个 gcpercent 的变量控制的,当新分配的内存占已在使用中的内存的比例超过 gcprecent 时就会触发。比如一次回收完毕后，内存的使用量为 5M，那么下次回收的时机则是内存分配达到 10M 的时候。也就是说，并不是内存分配越多，垃圾回收频率越高。 如果一直达不到内存大小的阈值呢？这个时候 GC 就会被定时时间触发，比如一直达不到 10M，那就定时（默认2min触发一次）触发一次 GC 保证资源的回收。

## GC 如何调优

通过 go tool pprof 和 go tool trace 等工具

* 控制内存分配的速度，限制 goroutine 的数量，从而提高赋值器对 CPU 的利用率。
* 减少并复用内存，例如使用 sync.Pool 来复用需要频繁创建临时对象，例如提前分配足够的内存来降低多余的拷贝。
* 需要时，增大 GOGC 的值，降低 GC 的运行频率。