---
layout: post
categories: Go
tags: [Go基础]
---

通常 PHP/C++ 通过指针引用计数来回收对象，但是这不能处理循环引用。为了避免引用计数的缺陷，后来出现了标记清除，分代等垃圾回收算法。Go 的垃圾回收官方形容为 **非分代 非紧缩 写屏障 并发标记清理**。标记清理算法的字面解释，就是将可达的内存块进行标记 mark，最后没有标记的不可达内存块将进行清理 sweep。

## 常见的垃圾回收算法

- 引用计数：每个对象维护一个引用计数，当被引用对象被创建或被赋值给其他对象时引用计数自动加 +1；如果这个对象被销毁，则计数 -1 ，当计数为 0 时，回收该对象。
  - 优点：对象可以很快被回收，不会出现内存耗尽或到达阀值才回收。
  - 缺点：不能很好的处理循环引用
- 标记-清除：从根变量开始遍历所有引用的对象，引用的对象标记 “被引用”，没有被标记的则进行回收。
  - 优点：解决了引用计数的缺点。
  - 缺点：需要 STW（stop the world），暂时停止程序运行。
- 分代收集：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，短的放入新生代，不同代有不同的回收算法和回收频率。
  - 优点：回收性能好
  - 缺点：算法复杂

## 三色标记法

三色标记法（tricolor mark-and-sweep algorithm）是传统 Mark-Sweep 的一个改进，它是一个并发的 GC 算法，在 Golang 中被用作垃圾回收的算法，但是也会有一个缺陷，可能程序中的垃圾产生的速度会大于垃圾收集的速度，这样会导致程序中的垃圾越来越多无法被收集掉。原理如下所示：

1. 初始状态下所有对象都是白色的。
2. 从根节点开始遍历所有对象，把遍历到的对象变成灰色对象
3. 遍历灰色对象，将灰色对象引用的对象也变成灰色对象，然后将遍历过的灰色对象变成黑色对象。
4. 循环步骤3，直到灰色对象全部变黑色。
5. 通过写屏障(write-barrier)检测对象有变化，重复以上操作
6. 收集所有白色对象（垃圾）。

也可以参考下面的动图辅助理解：

![01.awebp](/static/images/20211212/01.awebp)

> 为了避免GC的过程中新修改的引用关系到GC的结果发生错误，我们需要进行STW（Stop The World，停止所有正在运行的协程）。但是STW会影响程序的性能（尽管Golang目前已经可以做到1ms以下的STW），所以我们要通过写屏障技术尽可能地缩短STW的时间。
>
> 写屏障(Write Barrier)：该屏障之前的写操作和之后的写操作相比，先被系统其它组件感知。 好难懂哦，结合上面GC工作的完整流程就好理解了，就是在每一轮GC开始时会初始化一个叫做“屏障”的东西，然后由它记录第一次scan时各个对象的状态，以便和第二次re-scan进行比对，引用状态变化的对象被标记为灰色以防止丢失，将屏障前后状态未变化对象继续处理。

### 插入写屏障

golang 的回收没有混合屏障之前，一直是插入写屏障，由于栈赋值没有 hook 的原因，所以栈中没有启用写屏障，所以有 STW。golang 的解决方法是：只是需要在结束时启动 STW 来重新扫描栈。这个自然就会导致整个进程的赋值器卡顿，所以后面 golang 是引用混合写屏障解决这个问题。混合写屏障之后，就没有 STW。

### 删除写屏障

goalng 没有这一步，golang 的内存写屏障是由插入写屏障到混合写屏障过渡的。简单介绍一下，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮 GC 中被清理掉。

### 混合写屏障

* 混合写屏障继承了插入写屏障的优点，起始无需 STW 打快照，直接并发扫描垃圾即可；
* 混合写屏障继承了删除写屏障的优点，赋值器是黑色赋值器，GC 期间，任何在栈上创建的新对象，均为黑色。扫描过一次就不需要扫描了，这样就消除了插入写屏障时期最后 STW 的重新扫描栈；
* 混合写屏障扫描精度继承了删除写屏障，比插入写屏障更低，随着带来的是 GC 过程全程无 STW；
* 混合写屏障扫描栈虽然没有 STW，但是扫描某一个具体的栈的时候，还是要停止这个 goroutine 赋值器的工作的哈（针对一个 goroutine 栈来说，是暂停扫的，要么全灰，要么全黑哈，原子状态切换）。

## GC 触发条件

**主动触发：**调用 runtime.GC 

**被动触发：**

自动垃圾回收的触发条件有两个：

1. 超过内存大小阈值
2. 达到定时时间

阈值是由一个 gcpercent 的变量控制的,当新分配的内存占已在使用中的内存的比例超过 gcprecent 时就会触发。比如一次回收完毕后，内存的使用量为 5M，那么下次回收的时机则是内存分配达到 10M 的时候。也就是说，并不是内存分配越多，垃圾回收频率越高。 如果一直达不到内存大小的阈值呢？这个时候 GC 就会被定时时间触发，比如一直达不到 10M，那就定时（默认2min触发一次）触发一次 GC 保证资源的回收。

## GC 如何调优

通过 go tool pprof 和 go tool trace 等工具

* 控制内存分配的速度，限制 goroutine 的数量，从而提高赋值器对 CPU 的利用率。
* 减少并复用内存，例如使用 sync.Pool 来复用需要频繁创建临时对象，例如提前分配足够的内存来降低多余的拷贝。
* 需要时，增大 GOGC 的值，降低 GC 的运行频率。