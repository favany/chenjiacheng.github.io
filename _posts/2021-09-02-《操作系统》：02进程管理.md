---
layout: post
categories: 操作系统
tags: [操作系统]
---

## 进程的定义

进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位

## 进程的组成

### PCB

* 进程描述信息
  * 进程标识符 PID（当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的ID，用于区分不
    同的进程，类似于身份证号）
  * 用户标识符 UID
* 进程控制和管理信息
  * 进程当前状态
  * 进程优先级
* 资源分配清单
  * 程序段指针
  * 数据段指针
  * 键盘
  * 鼠标
* 处理机相关信息
  * 各种寄存器值（当进程切换时需要把进程当的的运行情况记录下来保存在 PCB 中，如程序计数器的值表示了当前程序执行到哪一句）

### 程序段

存放要执行的程序代码

### 数据段

存放程序运行中处理的各种数据

## 进程的组织方式

* 链接方式
  * 按进程状态将 PCB 分为多个队列
  * 操作系统持有指向各个队列的指针
* 索引方式
  * 按照进程状态建立几张索引表，各表项指向一个 PCB
  * 操作系统持有指向各个索引表的指针

## 进程的特征

* 动态性：进程是程序的一次执行过程，是动态地产生、变化和消亡的（动态性是进程最基本的特征）。
* 并发性：内存中有多个进程实体，各进程可并发执行。
* 独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位（进程是资源分配、接受调度的基本单位）。
* 异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供 “进程同步机制" 来解决异步问题（异步性会导致并发程序执行结果的不确定性）。
* 结构性：每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成。 

## 进程的状态与转换

### 三种基本状态

* 运行态（Running）：占有CPU，并在CPU上运行（注意：单核处理机环境下，每一时刻最多只有一个进程处于运行态。 双核环境下可以同时有两个进程处于运行态）
* 就绪态（Ready）：已经具备运行条件，但由于没有空闲CPU，而暂时不能运行（进程已经拥有了除处理机之外所有需要的资源，一且获得处理机，即可立即进入运行态开始运行。 即：万事俱备，只欠CPU）
* 阻塞态（Waiting/Blocked，又称：等待态）：因等待某一事件而暂时不能运行（如：等待操作系统分配打印机、等待读磁盘操作的结果。CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务）

### 另外两种状态

* 创建态（New，又称：新建态）：进程正在被创建，操作系统为进程分配资源、初始化 PCB
* 终止态（Terminated，又称：结束态）：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销 PCB

### 进程状态间的转换

![01.png](/static/images/20210902/01.png)

* 就绪态->运行态：进程被调度
* 运行态->就绪态：时间片到，或 CPU 被其他高优先级的进程抢占
* 运行态->阻塞态：等待系统资源分配，或等待某事件发生（主动行为）
* 阳塞态->就绪态：资源分配到位，等待的事件发生（被动行为）
* 创建态->就绪态：系统完成创建进程相关的工作 
* 运行态->终止态：进程运行结束，或运行过程中遇到不可修复的错误

## 进程控制

进程控制就是要实现进程状态的转换

**进程控制用原语实现：**

* 原语用关/开中断来实现
* 原语是一种特殊的程序
* 原语的执行**必须一气呵成，不可中断**

### 进程的创建

### 进程的终止

**撤销原语：**

1. 从 PCB 集合中找到终止进程的 PCB
2. 若进程正在运行，立即剥夺 CPU，将 CPU 分配给其他进程
3. 终止其所有子进程 
4. 将该进程拥有的所有资源归还给父进程或操作系统
5. 删除 PCB

**引起进程终止的事件：**

* 正常结束
* 异常结束
* 外界干预

### 进程的阻塞

**阻塞原语：**

1. 找到要阻塞的进程对应的 PCB
2. 保护进程运行现场，将 PCB 状态信息设置为 "阻塞态" 暂时停止进程运行
3. 将PCB插入相应事件的等待队列

**引起进程阻塞的事件：**

* 需要等待系统分配某种资源
* 需要等待相互合作的其他进程完成工作

### 进程的唤醒

**唤醒原语：**

1. 在事件等待队列中找到PCB
2. 将PCB从等待队列移除，设置进程为就绪态 因何事阻塞， 
3. 将PCB播入就绪队列，等待被调度 就应由何事 

**引起进程唤醒的事件：**

* 等待的事件发生 （因何事阻塞，就应由何事唤醒）

### 进程的切换

**切换原语：**

1. 将运行环境信息存入 PCB
2. PCB 移入相应队列
3. 选择另一个进程执行，并更新其 PCB
4. 根据PCB恢复新进程所需的运行环境

**引起进程切换的事件：**

* 当前进程时间片到
* 有更高优先级的进程到达
* 当前进程主动阻塞
* 当前进程终止

> 注意：阻塞和唤醒要成对出现

## 进程通信

### 共享存储

* 设置一个共享空间
* 要互斥地访问共享空间
* 两种方式
  * 基于数据结构（低级）
  * 基于存储区的共享（高级）

### 管道通信

* 设置一个特殊的共享文件（管道），其实就是一个缓冲区
* 一个管道只能实现半双工通信
* 实现双向同时通信要建立两个管道
* 各进程要互斥访问管道
* 写满时，不能再写。读空时，不能再读
* 没写满，不能读。没读空，不能写

### 消息传递

* 传递结构化的消息（消息头/消息体）
* 系统提供 “发送/接受原语”
* 两种方式
  * 直接通信方式：消息直接挂到接收方的消息队列里 
  * 间接（信箱）通信方式：消息先发到中间体（信箱）

## 线程、多线程模型

### 什么是线程，为什么要引入线程？

* 可理解为 "轻量级进程"
* 可增加并发度，减少并发带来的开销

### 引入线程机制后，有什么变化？（和传统的进程机制对比）

* 资源分配、处理机调度
* 并发性
* （实现并发的）系统开销

### 线程有哪些重要的属性

* 线程是处理机调度的单位，进程是资源分配的单位
* 同一进程的各线程共享进程拥有的资源
* 同一进程内的线程切换不会导致进程切换

### 线程的实现方式

* 用户级线程：从用户视角看的线程
* 内核级线程：从操作系统视角看的进程（内核级线程才是处理机分配的单位）
* 组合方式：上述两种方式的结合

### 多线程模型

* 多对一模型
  * 优点：进程管理开销小效率高
  * 缺点：一个线程阻塞会导致整个进程都被阻塞（并发度低）
* 一对一模型
  * 优点：进程管理开销大
  * 缺点：各个线程可分配到多核处理机并行执行，并发度高
* 多对多模型
  * 集二者之所长

## 处理机调度的概念、层次

### 基本概念

按某种算法选择一个进程将处理机分配给它

### 三个层次

* 高级调度（作业调度）：按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程
* 中级调度（内存调度）：按照某种规则，从挂起队列中选择合适的进程将其数据调回内存
* 低级调度（进程调度）：按照某种规则，从就绪队列中选择一个进程为其分配处理机 

### 三层调度的联系、对比

* 高级调度
  * 外存->内存（面向作业）
  * 发生频率：最低
* 中级调度
  * 外存->内存（面向进程）
  * 发生频率：中等
* 低级调度
  * 内存->CPU
  * 发生频率：最高

### 补充知识

* 为减轻系统负载，提高资源利用率，暂时不执行的进程会被调到外存从而变为 “挂起态”
* 七状态模型：在五状态模型的基础上加入了 “就绪挂起" 和 "阻塞挂起" 两种状态

## 调度的时机、切换与过程

### 时机

**什么时候需要进程调度？**

* 主动放弃
  * 进程正常终止
  * 运行过程中发生异常而终止 
  * 主动阻塞（如等待I/O）
* 被动放弃
  * 分给进程的时间片用完
  * 有更紧急的事情需要处理（如I/O中断）
  * 有更高优先级的进程进入就绪队列 

**什么时候不能进行进程调度？**

* 在处理中断的过程中
* 进程在操作系统内核程序临界区中 
* 原子操作过程中（原语）

### 切换与过程

* 狭义的"调度"和"切换”的区别
  * 狭义的进程调度指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）
  * 进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。
  * 广义的进程调度包含了选择一个进程和进程切换两个步骤。
* 切换过程
  * 对原来运行进程各种数据的保存
  * 对新的进程各种数据的恢复
* 重要结论：进程调度、切换是有代价的，并不是调度越频繁，并发度就越高 

### 方式

* 非剥夺调度方式（非抢占式）：只能由当前运行的进程主动放弃 CPU 
* 剥夺调度方式（抢占式）：可由操作系统剥夺当前进程的 CPU 使用权

## 调度算法的评价指标

### CPU利用率

* 利用率 = 忙碌的时间 / 总时间

### 系统吞吐量

* 系统吞吐量 = 总共完成了多少道作业 /  总共花了多少时间 

### 周转时间

* 周转时间 = 作业完成时间 - 作业提交时间
* 平均周转时间 = 各作业周转时间之和 / 作业数
* 带权周转时间 = 作业周转时间 / 作业实际运行的时间
* 平均带权周转时间 = 各作业带权周转时间之和 / 作业数

### 等待时间

* 进程 / 作业等待被服务的时间之和
* 平均等待时间即各个进程 / 作业等待时间的平均值

### 响应时间

* 从用户提交请求到首次产生响应所用的时间

## 调度算法

### 先来先服务（FCFS）

* 算法思想：主要从 “公平” 的角度考虑（类似于我们生活中排队买东西的例子）
* 算法规则：按照作业/进程到达的先后顺序进行服务
* 用于作业/进程调度：
  * 用于作业调度时，考虑的是哪个作业先到达后备队列
  * 用于进程调度时，考虑的是哪个进程先到达就绪队列
* 是否可抢占：非抢占式的算法
* 优缺点：
  * 优点：公平、算法实现简单
  * 排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即， FCFS 算法对长作业有利，对短作业不利（Eg：排队买奶茶...）
* 是否会导致饥饿：不会

### 短作业优先（SJF）

* 算法思想：追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间
* 算法规则：最短的作业/进程优先得到服务（所谓 “最短”，是指要求服务时间最短）
* 用于作业/进程调度：即可用于作业调度，也可用于进程调度。用于进程调度时称为 “短进程优先（SPF， Shortest Process First）算法”
* 是否可抢占：SJF 和 SP 是非抢占式的算法。但是他有抢占式的版本。最短剩余时间优先算法（SRTN, Shortest Remaining Time Next）
* 优缺点：
  * 优点：“最短的” 平均等待时间、平均周转时间
  * 缺点：不公平。对知作业有利，对长作业不利。可能产生饥饿现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先
* 是否会导致饥饿：会。如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生 “饥饿” 现象。如果一直得不到服务，则称为 “饿死”

### 高相应比优先（HRRN）

* 算法思想：要综合考虑作业/进程的等待时间和要求服务的时间
* 算法规则：在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务，晌应比 = (等待时间+要求服务时间)/要求服务时间
* 用于作业/进程调度：即可用于作业调度，也可用于进程调度
* 是否可抢占：非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比
* 优缺点：综合考虑了等待时间和运行时间（要求服务时间）等待时间相同时，要求服务时间短的优先（SJF 的优点）要求服务时间相同时，等待时间长的优先（FCFS 的优点）对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题
* 是否会导致饥饿：不会

### 时间片轮转调度算法（RR）

* 算法思想：公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应
* 算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完则剥夺处理机，将进程重新放到就绪队列队尾重新排队。
* 用于作业/进程调度：用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）
* 是否可抢占：若进程未能在时间片内运行完，将被强行剥布处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知 CPU 时间片已到
* 优缺点：
  * 优点：公平，响应快，适用于分时操作系统
  * 缺点：由于高频率的进程切换，因此有一定开销，不区分任务的紧急程度
* 是否会导致饥饿：不会

### 优先级调度算法

* 算法思想：随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序
* 算法规则：调度时选择优先级最高的作业/进程
* 用于作业/进程调度：既可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的 I/O 调度中
* 是否可抢占：抢占式、非抢占式都有，非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占
* 优缺点：
  * 优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。
  * 缺点：若源源不断地有高优先级进程到来，则可能导致饥饿会
* 是否会导致饥饿：不会

### 多级反馈队列算法

* 算法思想：对其他调度算法的折中权衡
* 算法规则：
  * 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
  * 新进程到达时先进入第 1 级队列，按 FCFS 原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾如果此时已经是在最下级的队列，则重新放回该队列队屏
  * 只有第 k 级队列为空时，才会为 k+1 级队头的进程分配时间片
* 用于作业/进程调度：用于进程调度
* 是否可抢占：抢占式的算法。在k级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，购由于新进程处于优先级中高的队列中，因此新进程会抢占处理机，原来运行的进程放回 k 级队列队尾。
* 优缺点：对各类型进程相对公平
  * FCFS 的优点：每个新到达的进程都可以很快就得到响应
  * RR 的优点：短进程只用较少的时间就可完成
  * SPF 的优点：不必实现估计进程的运行时间
  * 避免用户作假：可灵活地调整对各类进程的偏好程度，比如 CPU 密集型进程、I/O 密集型进程
  * 拓照：可以将因 I/O 而阻塞的进程重新放回原队列，这样 I/O 型进程就可以保持较高优先级
* 是否会导致饥饿：会

## 同步、互斥

### 进程同步

并发性带来了异步性，有时需要通过进程同步解决这种异步问题，有的进程之间需要相互配合地完成工作，各进程的工作推进需要遵循一定的先后顺序

### 进程互斥

对临界资源的访问，需要互斥的进行。即同一时间段内只能允许一个进程访问该资源

**四个部分：**

* 进入区：检查是否可进入临界区，若可进入，需要 "上锁” 
* 临界区：访问临界资源的那段代码 
* 退出区：负责 ”解锁” 
* 剩余区：其余代码部分 

**需要遵循的原则：**

* 空闲让进：临界区空闲时，应允许一个进程访问 
* 忙则等待：临界区正在被访问时，其他试图访问的进程需要等待 
* 有限等待：要在有限时间内进入临界区，保证不会饥饿 
* 让权等待：进不了临界区的进程，要释放处理机，防止忙等

## 进程互斥软件实现方法

* 单标志法
  * 在进入区只做 “检查” 不 "上锁"
  * 在退出区把临界区的使用权转交给另一个进程（相当于在退出区既给另一进程 "解锁”，又给自己 "上锁”）
  * 主要问题：不遵循 “空闲让进" 原则
* 双标志先检查
  * 在进入区先 "检查" 后 “上锁” 退出区 "解锁”
  * 主要问题：不遵循 "忙则等待" 原则
* 双标志后检查
  * 在进入区先 “加锁” 后 "检查”，退出区 "解锁”
  * 主要问题：不遵循 "空闲让进、有限等待" 原则，可能导致 ”饥饿”
* Peterson 算法
  * 在进入区 “主动争取一主动谦让一检查对方是否想进、已方是否谦让"
  * 主要问题：不遵循 ”让权等待" 原则，会发生 ”忙等"

## 进程互斥的硬件实现方法

* 中断屏蔽方法
  * 使用 “开/关中断” 指令实现
  * 优点：简单高效 
  * 缺点：只适用于单处理机，只适用于操作系统内核进程
* TestAndSet（TS指令/TSL指令）
  * old 记录是否已被上锁；再将 lock 设为 true；检查临界区是否已被上锁；(若已上锁，则循环重复前几步)
  * 优点：实现简单，适用于多处理机环境
  * 缺点：不满足 "让权等待"
* Swap指令（XCHG指令）
  * 逻辑上同 TSL

## 信号量机制

* 整型信号量
  * 用一个整数型变量作为信号量，数值表示某种资源数
  * 整型信号量与普通整型变量的区别：对信号量只能执行初始化、P、V三种操作
  * 整型信号量存在的问题：不满足让权等待原则

* 记录型信号量
  * S.value 表示某种资源数，S.L 指向等待该资源的队列
  * P 操作中一定是先 S.value--，之后可能需要执行 block 原语
  * V 操作中，一定是先 S.value++，之后可能需要执行 wakeup 原语
  * 注意：要能够自己推断在什么条件下需要执行 block 或 wakeup
  * 可以用记录型信号量实现系统资源的 "申请" 和 "释放"
  * 可以用记录型信号量实现进程互斥、进程同步

* 实现进程互斥
  * 分析问题，确定临界区
  * 设置互斥信号量，初值为 1（互斥问题，信号量初值为 1）
  * 临界区之前对信号量执行 P 操作
  * 临界区之后对信号量执行 V 操作
* 实现进程同步
  * 分析问题，找出哪里需要实现 “一前一后" 的同步关系
  * 设置同步信号量，初始值为 0（同步问题，信号量初值为 0）
  * 在 "前操作" 之后执行 V 操作
  * 在 "后操作" 之前执行 P 操作
* 实现进程的前驱关系
  * 分析问题画出前驱图，把每一对前驱关系都看成一个同步问题（前驱关系问题本质上就是更复杂的同步问题）
  * 为每一对前驱关系设置同步信号量，初值为 0
  * 在每个 ”前操作" 之后执行 V 操作
  * 在每个 "后操作" 之前执行 P 操作

## 管程

* 为什么要引入管程：解决信号量机制编程麻烦、易出错的问题
* 组成
  * 共享数据结构
  * 对数据结构初始化的语句	
  * 一组用来访问数据结构的过程（函数）
* 基本特征
  * 各外部进程/线程只能通过管程提供的特定 "入口” 才能访问共享数据
  * 每次仅允许一个进程在管程内执行某个内部过程
* 补充
  * 各进程必须互斥访问管程的特性是由编译器实现的
  * 可在管程中设置条件变量及等待/唤醒操作以解决同步问题

## 死锁

* 什么是死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进
* 死锁、饥饿、死循环的区别
  * 死锁：至少是两个进程一起死锁，死锁进程处于阻塞态
  * 饥饿：可以只有一个进程饥饿，饥饿进程可能阻塞也可能就绪
  * 死循环：可能只有一个进程发生死循环，死循环的进程可上处理机
  * 死锁和饥饿是操作系统要解决的问题，死循环是应用程序员要解决的
* 死锁产生的必要条件
  * 互斥条件：对必须互斥使用的资源的争抢才会导致死锁	
  * 不剥夺条件：进程保持的资源只能主动释放，不可强行剥夺	
  * 请求和保持条件：保持着某些资源不放的同时，请求别的资源
  * 循环等待条件
    * 存在一种进程资源的循环等待链
    * 循环等待未必死锁，死锁一定有循环等待
* 什么时候会发生死锁：对不可剥夺资源的不合理分配，可能导致死锁
* 死锁的处理策略
  * 预防死锁：破坏死锁产生的四个必要条件
    * 破坏互斥条件
      * 将临界资源改造为可共享使用的资源（如 SPOOLing 技术）
      * 缺点：可行性不高，很多时候无法破坏互斥条件
    * 破坏不剥夺条件
      * 方案一，申请的资源得不到满足时，立即释放拥有的所有资源
      * 方案二，申请的资源被其他进程占用时，由操作系统协助剥夺(考虑优先级) 
      * 缺点：实现复杂；剥夺资源可能导致部分工作失效；反复申请和释放导致系统开销大；可能导致饥饿
    * 破坏请求和保持条件
      * 运行前分配好所有需要的资源，之后一直保持
      * 缺点：资源利用率低;可能导致饥饿
    * 破坏循环等待条件
      * 给资源编号，必须按编号从小到大的顺序申请资源
      * 缺点：不方便增加新设备；会导致资源浪费；用户编程麻烦
  * 避免死锁：避免系统进入不安全状态（银行家算法）
  * 死锁的检测和解除：允许死锁发生，系统负责检测出死锁并解除