## 进程

### 进程的概念

**程序段、数据段、PCB** 三部分组成了进程实体（进程映像）。一般情况下，我们把进程实体就简称为进程，例如，所谓创建进程，实质上是创建进程实体中的 PCB；而撤销进程，实质上是撤销进程实体中的 PCB。

>  注意：PCB 是进程存在的唯一标志!

**从不同的角度，进程可以有不同的定义，比较传统典型的定义有:**

1. 进程是程序的一次执行过程。
2. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。
3. 进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。

引入进程实体的概念后，可护进程定义为：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。

> 注意：严格来说，进程实体和进程并不一样，进程实体是静态的，进程则是动态的。

### 进程的特征

进程和程序是两个截然不同的概念，相比于程序，进程拥有以下特征：

* **动态性：**进程是程序的一次执行过程，是动态地产生、变化和消亡的（动态性是进程最基本的特征）。

* **并发性：**内存中有多个进程实体，各进程可并发执行（进程是资源分配、接受调度的基本单位）。

* **独立性：**进程是能独立运行、独立获得资源、独立接受调度的基本单位。

* **异步性：**各进程按各自独立的、不可预知的速度向前推进，操作系统要提供 “进程同步机制" 来解决异步问题（异步性会导致并发程序执行结果的不确定性）。

* **结构性：**每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成。 

### 进程的状态与转换

进程是程序的一次执行。在这个执行过程中，有时进程正在被 CPU 处理，有时又需要等待 CPU 服务，可见进程的状态是会有各种变化。为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态。

**进程的三种基本状态：**

* **运行态(Running)：**占有 CPU，并在 CPU 上运行 。（注意：单核处理机环境下，每一时刻最多只有一个进程处于运行态，双核环墙下可以同时有两个进程处于运行态） 。 

* **就绪态(Ready)：**已经具备运行条件，但由于没有空闲 CPU，而暂时不能运行（进程已经拥有了除处理机之外所有需要的资源，一旦获得处理机，即可立即进入运行态开始运行。即：万事俱备，只欠 CPU）。

* 阻塞态(Waiting/Blocked，又称：等待态)：因等待某一事件而暂时不能运行（如：等待操作系统分配打印机，等待速研盘操作的结果。CPU 是计放机中最品贵的部件，为了提高 CPU 的利用率，需要先将其他进程需要的资海分配到位，才能得到 CPU 的服务）。

**进程状态的转换：**

![image-20210902111221992](2021-09-02-《操作系统》：02进程管理.assets/image-20210902111221992.png)

### 进程控制

进程控制的主要功能是对系统的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。

简化理解：反正进程控制就是要实现进程状态转换。

![image-20210902112225753](2021-09-02-《操作系统》：02进程管理.assets/image-20210902112225753.png)

**1、进程的创建**

允许一个进程创建另一个进程。此时创建者称为父进程，被创建的进程称为子进程。子进程可以继承父进程所拥有的资源。当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。此外，在撤销父进程时，必须同时撤销其所有的子进程。

在操作系统中，终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求等都会引起进程的创建。操作系统创建一个新进程的过程如下（创建原语）：

1. 为新进程分配一个唯一的进程标识号，并申请一个空白的 PCB（PCB是有限的）。若 PCB 申请失败，则创建失败。
2. 为进程分配资源，为新进程的程序和数据及用户栈分配必要的内存空间（在PCB中体现）注意，若资源不足（如内存空间），则并不是创建失败，而是处于阻塞态，等待内存资源。
3. 初始化PCB主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。
4. 若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行。

**2、进程的终止**

引起进程终止的事件主要有：

1. 正常结束，表示进程的任务已完成并准备退出运行。
2. 异常结束，表示进程在运行时，发生了某种异常事件，使程序无法继续运行，如存储区越界、保护错、非法指令、特权指令错、运行超时、算术运算错、I/0故障等。
3. 外界干预，指进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止。

操作系统终止进程的过程如下（撤销原语）：

1. 根据被终止进程的标识符，检索 PCB，从中读出该进程的状态。
2. 若被终止进程处于执行状态，立即终止该进程的执行，将处理机资源分配给其他进程。
3. 若该进程还有子孙进程，则应将其所有子孙进程终止。
4. 将该进程所拥有的全部资源，或归还给其父进程，或归还给操作系统。
5. 将该PCB从所在队列（链表）中删除。

**3、进程的阻塞和唤醒**

正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成新数据尚未到达或无新工作可做等，由系统自动执行阻塞原语（Block），使自己由运行态变为阳塞态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU）才可能将其转为阻塞态。阻塞原语的执行过程如下：

1. 找到将要被阻塞进程的标识号对应的 PCB。
2. 若该进程为运行态，则保护其现场，将其状态转为阻塞态，停止运行。
3. 把该 PCB 插入相应事件的等待队列，将处理机资源调度给其他就绪进程。

当被阻塞进程所期待的事件出现时如它所启动的 I/O 操作已完成或其所期待的数据已到达由有关进程（比如，释放该 I/O 设备的进程，或提供数据的进程）调用唤醒原语（Wakeup），将等待该事件的进程唤醒。唤醒原语的执行过程如下：

1. 在该事件的等待队列中找到相应进程的 PCB。
2. 将其从等待队列中移出，并置其状态为就绪态。
3. 把该PCB插入就绪队列，等待调度程序调度。

> 需要注意的是，Block原语和Wakeup原语是一对作用刚好相反的原语，必须成对使用。Block原语是由被阻塞进程自我调用实现的，而Wakeup原语则是由一个与被唤醒进程合作或被其他相关的进程调用实现的。

**4、进程的切换**

对于通常的进程而言，其创建、撤销及要求由系统设备完成的 I/Q 操作，都是利用系统调用而进入内核，再由内核中的相应处理程序予以完成的。进程切换同样是在内核的支持下实现的，因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。

进程切换是指处理机从一个进程的运行转到另一个进程上运行，在这个过程中，进程的运行环境产生了实质性的变化。进程切换的过程如下:

1. 保存处理机上下文，包括程序计数器和其他寄存器。
2. 更新 PCB 信息。
3. 把进程的 PCB 移入相应的队列，如就绪、在某事件阻寒等队列。
4. 选择另一个进程执行，并更新其 PCB。
5. 更新内存管理的数据结构。
6. 恢复处理机上下文。

注意，进程切换与处理机模式切换是不同的，模式切换时，处理机逻辑上可能还在同一进程中运行。若进程因中断或异常进入核心态运行，执行完后又回到用户态刚被中断的程序运行，则操作系统只需恢复进程进入内核时所保存的 CPU 现场，而无须改变当前进程的环境信息。但若要切换进程，当前运行进程改变了，则当前进程的环境信息也需要改变。

> 注意：“调度” 和 “切换” 的区别。调度是指决定资源分配给哪个进程的行为，是一种决策行为；切换是指实际分配的行为，是执行行为。一般来说，先有资源的调度，然后才有进程的切换，

### 进程的组织

进程是一个独立的运行单位，也是操作系统进行资源分配和调度的基本单位。它由以下三部分组成，其中最核心的是进程控制块（PCB）。

**1、进程控制块**

进程创建时，操作系统为它新建一个PCB，该结构之后常驻内存，任意时刻都可以存取，并在进程结束时删除。PCB是进程实体的一部分，是进程存在的唯一标志。

进程执行时，系统通过其 PCB 了解进程的现行状态信息，以便对其进行控制和管理;进程结束时，系统收回其 PCB，该进程随之消亡。操作系统通过 PCB 表来管理和控制进程。

**2、程序段**

程序段就是能被进程调度程序调度到 CPU 执行的程序代码段。注意，程序可被多个进程共早，即多个进程可以运行同一个程序。

**3、数据段**

一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。

### 进程的通信

进程通信就是指进程之间的信息交换。进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。

为了保证安全，一个进程不能直接访问另一个进程的地址空间。但是进程之间的信息交换又是必须实现的。保证进程间的安全通信，操作系统提供了一些方法：

**1、共享存储**

两个进程对共享空间的访问必须是互斥的（互斥访问通过操作系统提供的工具实现）。

操作系统只负责提供共享空间和同步互斥工具（如 P、V 操作）

![image-20210902115250328](2021-09-02-《操作系统》：02进程管理.assets/image-20210902115250328.png)

**基于数据结构的共享：**比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式。

**基于存储区的共享：**在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式。

**2、消息传递**

进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的 “发送消息/接收消息” 两个原语进行数据交换。

![image-20210902115415785](2021-09-02-《操作系统》：02进程管理.assets/image-20210902115415785.png)

**3、管道通信**

![image-20210902115600816](2021-09-02-《操作系统》：02进程管理.assets/image-20210902115600816.png)

1. 管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。
2. 各进程要互斥地访问管道。
3. 数据以字符流的形式写入管道，当管道写满时，写进程的 write() 系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的 read() 系统调用将被阳塞。
4. 如果没写满，就不介许读。如果没读空，就不介许写。
5. 数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。

## 线程

### 线程的概念

**线程是一个基本的 CPU 执行单元，也是程序执行流的最小单位**。引入线程之后，不仅是进程之间可以并发，进程内的**各线程之间也可以并发**，从而进一步**提升了系统的并发度**，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件）。

引入线程后，进程只作为除 CPU 之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的），线程则作为处理机的分配单元。

可以把线程理解为 “轻量级进程”。

### 线程 VS 进程

**资源分配、调度：**传统进程机制中，进程是资源分配、调度的基本单位，引入线程后，进程是资源分配的基本单位，线程是调度的基本单位。

**并发性：**传统进程机制中，只能进程间并发，引入线程后，各线程间也能并发，提升了并发度。

**系统开销：**传统的进程间并发，需要切换进程的运行环境，系统开销很大，线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小，引入线程后，并发所带来的系统开销减小。

### 线程的属性

* 线程是处理机调度的单位
* 多 CPU 计算机中，各个线程可占用不同的 CPU
* 每个线程都有一个线程 ID、线程控制块（TCB）
* 线程也有就绪、阻寒、运行三种基本状态
* 线程几平不拥有系统资源
* 同一进程的不同线程间共享进程的资流
* 由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预
* 同一进程中的线程切换，不会引起进程切换
* 不同进程中的线程切换，会引起进程切换
* 切换同进程内的线程，系统开销很小
* 切换进程，系统开销较大

### 线程的实现方式

**用户级线程（User-Level Thread，ULT）**

![image-20210902154543101](2021-09-02-《操作系统》：02进程管理.assets/image-20210902154543101.png)

用户级线程由院用程序通过线程库实现。所有的线程管理工作都由应用程序负责（包括线程切换）。用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在（用户级线程对用户不透明，对操作系统透明）。

可以这样理解，“用户级线程” 就是 “从用户视角看能看到的线程”。

**内核级线程（Kernel-Level Thread，KLT，又称 “内核支持的线程”）**

![image-20210902155113674](2021-09-02-《操作系统》：02进程管理.assets/image-20210902155113674.png)

内核级线程的管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。

可以这样理解，“内核级线程” 就是 “从操作系统内核视角看能看到的线程”。

**在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式：将 n 个用户级线程映射到 m 个内核级线程上（n>=m）**

操作系统只 “看得见” 内核级线程，因此只有内核级线程才是处理机分配的单位。

![image-20210902155509274](2021-09-02-《操作系统》：02进程管理.assets/image-20210902155509274.png)

例如：上边这个模型中，该进程由两个内核级线程，三个用户级线程，在用户看来，这个进程中有三个线程。但即使该进程在一个 4 核处理机的计算机上运行，也最多只能被分配到两个核，最多只能有两个用户线程并行执行。

### 多线程模型

有些系统同时支持用户线程和内核线程，由此产生了不同的多线程模型，即实现用户级线程和内核级线程的连接方式。

**多对一模型：多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。**

* 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高

* 缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行

**一对一模型：一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。**

* 优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。
* 缺点：一个用户进程会占用多个内核级线程线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。

**多对多模型：n 用户及线程映射到 m 个内核级线程(n>=m)。每个用户进程对应 m 个内核级线程。**

* 特点：克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。

## 处理机调度

当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定**某种规则来决定处理这些任务的顺序**，这就是 “调度” 研究的问题。

在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。处理机调度，就是从就绪队列中**按照一定的算法选择一个进程并将处理机分配给它运行**，以实现进程的并发执行。

### 调度的层次

**1、高级调度**

![image-20210902222858183](2021-09-02-《操作系统》：02进程管理.assets/image-20210902222858183.png)

由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。

**高级调度（作业调度）**。按一定的原则从外存上处于后备队列的作业中挑选一个(或多个)作业给他们分配内存等必要资源，**并建立相应的进程(建立PCB)，以使它(们)获得竞争处理机的权利。**

高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。**作业调入时会建立相应的 PCB，作业调出时才撤销 PCB**。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。

**2、中级调度**

![image-20210902223005523](2021-09-02-《操作系统》：02进程管理.assets/image-20210902223005523.png)

引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。

这么做的目的是为了**提高内存利用率和系统吞吐量**。

暂时调到外存等待的进程状态为**挂起状态**。值得注意的是，PCB 并不会一起调到外存，而是会常驻内存。PCB 中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程 PCB 会被放到的挂起队列中。

**中级调度（内存调度）**，就是要决定将哪个处于挂起状态的进程重新调入内存。

一个进程可能会被多次调出、调入内存，因此**中级调度发生的频率要比高级调度重高**。

**3、低级调度**

![image-20210902223205819](2021-09-02-《操作系统》：02进程管理.assets/image-20210902223205819.png)

**低级调度（进程调度）**，其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。

进程调度是操作系统中**最基本的一种调度**，在一般的操作系统中都必须配置进程调度。进程调度的**频率很高**，一般几十毫秒一次。

**三层调度的联系、对比**

![image-20210902223743352](2021-09-02-《操作系统》：02进程管理.assets/image-20210902223743352.png)

### 调度的时机、切换与过程

### 进程调度方式

### 调度的基本准则

### 典型的调度算法

2．1 进程与线程 29
2．1．1 进程的概念和特征 29
2．1．2 进程的状态与转换 30
2．1．3 进程控制 31
2．1．4 进程的组织 33
2．1．5 进程的通信 34
2．1．6 线程概念和多线程模型 35
2．1．7 本节小结 38
2．1．8 本节习题精选 39
2．1．9 答案与解析 44
2．2 处理机调度 51
2．2．1 调度的概念 51
2．2．2 调度的时机、切换与过程 53
2．2．3 进程调度方式 53
2．2．4 调度的基本准则 54
2．2．5 典型的调度算法 54
2．2．6 本节小结 58
2．2．7 本节习题精选 58
2．2．8 答案与解析 65
2．3 进程同步 75
2．3．1 进程同步的基本概念 75
2．3．2 实现临界区互斥的基本方法 76
2．3．3 信号量 79
2．3．4 管程 82
2．3．5 经典同步问题 84
2．3．6 本节小结 90
2．3．7 本节习题精选 91
2．3．8 答案与解析 102
2．4 死锁 121
2．4．1 死锁的概念 121
2．4．2 死锁的处理策略 123
2．4．3 死锁预防 124
2．4．4 死锁避免 124
2．4．5 死锁检测和解除 129
2．4．6 本节小结 130
2．4．7 本节习题精选 130
2．4．8 答案与解析 136
2．5 本章疑难点 145