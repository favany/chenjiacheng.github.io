---
layout: post
---

## 基础

### 数据库三大范式

* 第一范式：1NF 是对属性的**原子性约束**，要求属性具有原子性，**不可再分解**；
* 第二范式：2NF 是对记录的**惟一性约束**，要求记录有惟一标识，即**实体的惟一性**；
* 第三范式：3NF 是对字段**冗余性的约束**，即任何字段不能由其他字段派生出来，它**要求字段没有冗余**。

在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。

**范式化设计优缺点**

* 优点：可以尽量得减少数据冗余，使得更新快，体积小
* 缺点：对于查询需要多个表进行关联，减少写得效率增加读得效率，更难进行索引优化

**反范式化设计优缺点**

* 优点：可以减少表得关联，可以更好得进行索引优化
* 缺点：数据冗余以及数据异常，数据得修改需要更多的成本

### MySQL 中有哪几种锁？

-   MyISAM 支持表锁，InnoDB 支持表锁和行锁，默认为行锁
-   表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低
-   行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高

### 什么是临时表，何时删除临时表？

什么是临时表？MySQL 在执行 SQL 语句的过程中 通常会临时创建一些存储中间结果集的表，临时表只对当前连接可见，在连接关闭时，临时表会被删除并释放所有表空间。

临时表分为两种：一种是内存临时表，一种是磁盘临时表，什么区别呢？内存临时表使用的是 MEMORY 存储引擎，而临时表采用的是 MylSAM 存储引擎。

MySQL 会在下面这几种情况产生临时表。

* 使用 UNION 查询：UNION 有两种，一种是 UNION，一种是 UNION ALL，它们都用于联合查询;区别是使用 UNION 会去掉两个表中的重复数据，相当于对结果集做了一下 去重(distinct)。使用 UNIONALL，则不会排重，返回所有
  的行。使用 UNION 查询会产生临时表。
* 使用 TEMPTABLE 算法或者是 UNION 查询中的视图。TEMPTABLE 算法是一种创建临时表的算法，它是将结果放置到临时表中，意味这要 MySQL 要先创建好一个临时表，然后将结果放到临时表中去，然后再使用这个临时表进行
  相应的查询。
* ORDER BY 和 GROUPBY 的子句不一样时也会产生临时表。
* DISTINCT 查询并且加上 ORDER BY 时; SQL 中用到 SQL_SMALL_RESULT 选项时;如果查询结果比较小的时候，可以加上 SQL SMALL RESULT 来优化，产生临时表
* FROM 中的子查询;
* EXPLAIN 查看执行计划结果的 Extra 列中，如果使用 Using Temporary 就表示会用到临时表。

### 使用 union 和 union all 时需要注意些什么？

通过 union 连接的 SQL 分别单独取出的列数必须相同。

使用 union 时，多个相等的行将会被合并，由于合升比较耗时，一般不直接使用 union 进行合并，而是通常采用 union all 进行合并。

### 什么是存储过程

我们常用的操作数据库语言 SQL 语句在执行的时候需要要先编译，然后执行，而存储过程（Stored Procedure）是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它。

一个存储过程是一个可编程的函数，它在数据库中创建并保存。它可以有SQL语句和一些特殊的控制结构组成。当希望在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。数据库中的存储过程可以看做是对编程中面向对象方法的模拟。它允许控制数据的访问方式。

优点：

* 存储过程增强了 SQL 语言的功能和灵活性。存储过程可以用流控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。
* 存储过程允许标准组件是编程。存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，对应用程序源代码毫无影响。
* 存储过程能实现较快的执行速度。如果某一操作包含大量的 Transaction-SQL 代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的 Transaction-SQL 语句在每次运行时都要进行编译和优化，速度相对要慢一些。
* 存储过程能过减少网络流量。针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的 Transaction-SQL 语句被组织程存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大增加了网络流量并降低了网络负载。
* 存储过程可被作为一种安全机制来充分利用。系统管理员通过执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。

### 内连接、左连接、右连接有什么区别？

- Inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集
- left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。
- right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。

### 什么是内连接、外连接、交叉连接、笛卡尔积呢？

- 内连接（inner join）：取得两张表中满足存在连接匹配关系的记录。
- 外连接（outer join）：取得两张表中满足存在连接匹配关系的记录，以及某张表（或两张表）中不满足匹配关系的记录。
- 交叉连接（cross join）：显示两张表所有记录一一对应，没有匹配关系进行筛选，也被称为：笛卡尔积。

### 主从复制 binlog 格式有哪几种？

* STATEMENT：基于语句的日志记录，把所有写操作的 sql 语句写入 binlog （默认） 例如 update xxx set update_time = now () where pk_id = 1，这时，主从的 update_time 不一致 优点： 成熟的技术。 更少的数据写入日志文件。当更新或删除影响许多行时，这将导致 日志文件所需的存储空间大大减少。这也意味着从备份中获取和还原可以更快地完成。 日志文件包含所有进行了任何更改的语句，因此它们可用于审核数据库。
  缺点： 有很多函数不能复制，例如 now ()、random ()、uuid () 等
* ROW：基于行的日志记录，把每一行的改变写入 binlog，假设一条 sql 语句影响 100 万行，从节点需要执行 100 万次，效率低。 优点：可以复制所有更改，这是最安全的复制形式 缺点：如果该 SQL 语句更改了许多行，则基于行的复制可能会向二进制日志中写入更多的数据。即使对于回滚的语句也是如此。这也意味着制作和还原备份可能需要更多时间。此外，二进制日志被锁定更长的时间以写入数据，这可能会导致并发问题。
* MIXED：混合模式，如果 sql 里有函数，自动切换到 ROW 模式，如果 sql 里没有会造成主从复制不一致的函数，那么就使用 STATEMENT 模式。（存在问题：解决不了系统变量问题，例如 @@host name，主从的主机名不一致）

### MySQL常用的存储引擎有什么？它们有什么区别？

- InnoDB

  InnoDB是MySQL的默认存储引擎，支持事务、行锁和外键等操作。

- MyISAM

  MyISAM是MySQL5.1版本前的默认存储引擎，MyISAM的并发性比较差，不支持事务和外键等操作，默认的锁的粒度为表级锁。

|          |                InnoDB                |                         MyISAM                         |
| :------: | :----------------------------------: | :----------------------------------------------------: |
|   外键   |                 支持                 |                         不支持                         |
|   事务   |                 支持                 |                         不支持                         |
|    锁    |            支持表锁和行锁            |                        支持表锁                        |
| 可恢复性 |         根据事务日志进行恢复         |                       无事务日志                       |
|  表结构  | 数据和索引是集中存储的，.ibd 和 .frm | 数据和索引是分开存储的，数据`.MYD`，索引`.MYI` 和 .frm |
| 查询性能 |      一般情况相比于 MyISAM 较差      |               一般情况相比于 InnoDB 较差               |
|   索引   |               聚簇索引               |                       非聚簇索引                       |
|   其他   |      InnoDB 不保存表的具体行数       |          MyISAM 用一个变量保存了整个表的行数           |

### MySQL 的数据类型有哪些

- 整数

  TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT 分别占用8、16、24、32、64位存储空间。值得注意的是，INT(10) 中的 10 只是表示显示字符的个数，并无实际意义。一般和 UNSIGNED ZEROFILL 配合使用才有实际意义，例如，数据类型 INT(3)，属性为 UNSIGNED ZEROFILL，如果插入的数据为 3 的话，实际存储的数据为 003。

- 浮点数

  FLOAT、DOUBLE 及 DECIMAL 为浮点数类型，DECIMAL 是利用字符串进行处理的，能存储精确的小数。相比于 FLOAT 和 DOUBLE，DECIMAL 的效率更低些。FLOAT、DOUBLE 及 DECIMAL 都可以指定列宽，例如 FLOAT(5,2) 表示一共 5 位，两位存储小数部分，三位存储整数部分。

- 字符串

  字符串常用的主要有 CHAR 和 VARCHAR，VARCHAR 主要用于存储可变长字符串，相比于定长的 CHAR 更节省空间。CHAR 是定长的，根据定义的字符串长度分配空间。

  应用场景：对于经常变更的数据使用 CHAR 更好，CHAR 不容易产生碎片。对于非常短的列也是使用 CHAR 更好些，CHAR 相比于 VARCHAR 在效率上更高些。一般避免使用 TEXT/BLOB 等类型，因为查询时会使用临时表，造成严重的性能开销。

- 日期

  比较常用的有 year、time、date、datetime、timestamp 等，datetime 保存从 1000 年到 9999 年的时间，精度到秒，使用 8 字节的存储空间，与时区无关。timestamp 和 UNIX 的时间戳相同，保存从 1970年1月1日 午夜到 2038 年的时间，精度到秒，使用四个字节的存储空间，并且与时区相关。

  应用场景：尽量使用 timestamp，相比于 datetime 它有着更高的空间效率。

### 说说你 SQL 调优思路吧

- 「表结构优化」

  * 拆分字段
  * 字段类型的选择

  - 字段类型大小的限制
  - 合理的增加冗余字段
  - 新建字段一定要有默认值

- 「索引方面」

  * 索引字段的选择

  - 利用好mysql支持的索引下推，覆盖索引等功能
  - 唯一索引和普通索引的选择

- 「查询语句方面」

  * 避免索引失效

  - 合理的书写where条件字段顺序
  - 小表驱动大表
  - 可以使用force index()防止优化器选错索引

- 「分库分表」

### 字段为什么要设置成  NOT NULL？

首先说一点，NULL 和空值是不一样的，空值是不占用空间的，而 NULL 是占用空间的，所以字段设为 NOT NULL 后仍然可以插入空值。

字段设置成 NOT NULL 主要有以下几点原因：

* NULL 值会影响一些函数的统计，如 count，遇到 NULL 值，这条记录不会统计在内。
* B 树不存储 NULL，所以索引用不到 NULL，会造成第一点中说的统计不到的问题。
* NOT IN 子查询在有 NULL 值的情况下返回的结果都是空值。

### varchar 和 char 的区别？

- varchar 表示变长，char 表示长度固定。
- 存储容量不同，对于 char 来说，最多能存放的字符个数为 255。对于 varchar，最多能存放的字符个数是 65532。
- 存储速度不同，char 长度固定，存储速度会比 varchar 快一些，但在空间上会占用额外的空间，属于一种空间换时间的策略。而 varchar 空间利用率会高些，但存储速度慢，属于一种时间换空间的策略。
- 当 char 值被存储时，它们被用空格填充到特定长度，检索 char 值时需删除尾随空格。

**为什么 varchar 建议不要超过255?**

- 当定义 varchar 长度小于等于 255 时，长度标识位需要一个字节(utf-8编码)。
- 当大于 255 时，长度标识位需要两个字节，并且建立的索引也会失效。

**varchar(10) 和 int(10) 代表什么含义?**

- varchar 的 10 代表了申请的空间长度，也是可以存储的数据的最大长度。
- int 的10 只是代表了展示的长度，不足 10 位以 0 填充。
- int(1) 和int (10) 所能存储的数字大小以及占用的空间都是相同的，只是在展示时按照长度展示。

### drop、delete 和 truncate 的区别？

|          | drop                               | delete                               | truncate                     |
| :------- | :--------------------------------- | :----------------------------------- | :--------------------------- |
| 速度     | 快                                 | 逐行删除，慢                         | 较快                         |
| 类型     | DDL                                | DML                                  | DDL                          |
| 回滚     | 不可回滚                           | 可回滚                               | 不可回滚                     |
| 删除内容 | 删除整个表，数据行、索引都会被删除 | 表结构还在，删除表的一部分或全部数据 | 表结构还在，删除表的全部数据 |

总结：删除整个表，使用drop，删除表的部分数据使用delete，保留表结构删除表的全部数据使用truncate。

### 慢日志查询的理解和优化

慢查询一般用于记录执行时间超过某个临界值的 SQL 语句的日志。

**如何查找查询速度慢的原因？**

记录慢查询日志，分析查询日志，可以使用 pt-query-digest 工具进行分析。

相关参数：

- slow_query_log：是否开启慢日志查询，1表示开启，0表示关闭。
- slow_query_log_file：MySQL数据库慢查询日志存储路径。
- long_query_time：慢查询阈值，当SQL语句查询时间大于阈值，会被记录在日志上。
- log_queries_not_using_indexes：未使用索引的查询会被记录到慢查询日志中。
- log_output：日志存储方式。“FILE”表示将日志存入文件。“TABLE” 表示将日志存入数据库。

**如何对慢查询进行优化？**

- 使用 explain 分析语句的执行计划，查看SQL语句的索引是否命中。
- 优化数据库的结构，将字段很多的表分解成多个表，或者考虑建立中间表。
- 优化 LIMIT 分页。

### SQL 语句的执行顺序？

```sql
SELECT DISTINCT 
	select_list 
FROM 
	left_table 
LEFT JOIN 
	right_table ON join_condition 
WHERE 
	where_condition 
GROUP BY 
	group_by_list 
HAVING 
	having_condition 
ORDER BY 
	order_by_condition
```

- FROM：对SQL语句执行查询时，首先对关键字两边的表以笛卡尔积的形式执行连接，并产生一个虚表V1。虚表就是视图，数据会来自多张表的执行结果。
- ON：对FROM连接的结果进行ON过滤,并创建虚表V2
- JOIN：将ON过滤后的左表添加进来，并创建新的虚拟表V3
- WHERE：对虚拟表V3进行WHERE筛选，创建虚拟表V4
- GROUP BY：对V4中的记录进行分组操作，创建虚拟表V5
- HAVING：对V5进行过滤，创建虚拟表V6
- SELECT：将V6中的结果按照SELECT进行筛选，创建虚拟表V7
- DISTINCT：对V7表中的结果进行去重操作，创建虚拟表V8，如果使用了GROUP BY子句则无需使用DISTINCT，因为分组的时候是将列中唯一的值分成一组，并且每组只返回一行记录，所以所有的记录都h是不同的。
- ORDER BY：对V8表中的结果进行排序。

## 索引

### 什么是索引

* 索引是一种特殊的文件（InnoDB 数据表上的索引是表空间的一个组成部分），它们包含着对数据表里所有记录的引用指针。
* 索引是一种数据结构。数据库索引是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用 B 树及其变种 B+树。
* 更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。

### 索引的优缺点

优点

* 唯一索引可以保证数据库表中每一行的数据的唯一性
* 索引可以加快数据查询速度，减少查询时间
* 将随机 I/O 变成顺序 I/O（因为B+树的叶子节点是连接在一起的）
* 加速表与表之间的连接

缺点

* 时间方面：创建索引和维护索引要耗费时间
* 空间方面：索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间
* 表中的数据进行增、删、改的时候，索引也要动态的维护

### 索引的类型

- 主键索引：数据列不允许重复，不允许为 NULL，一个表只能有一个主键。
- 唯一索引：数据列不允许重复，允许为 NULL 值，一个表允许多个列创建唯一索引。
- 普通索引：基本的索引类型，没有唯一性的限制，允许为 NULL 值。
- 全文索引：是目前搜索引擎使用的一种关键技术，对文本的内容进行分词、搜索。
- 组合索引：多列值组成一个索引，用于组合搜索，效率大于索引合并

### MyISAM 索引与 InnoDB 索引的区别

* InnoDB 索引是聚簇索引，MyISAM 索引是非聚簇索引。
* InnoDB 的主键索引的叶子节点存储着行数据，因此主键索引非常高效。
* MyISAM 索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。
* InnoDB 非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。

### 什么是聚簇索引和非聚集索引

* 聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据
* 非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam 通过 key_buffer 把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在 key buffer 命中时，速度慢的原因。

### 聚集索引与非聚集索引的区别

- 一个表中只能拥有一个聚集索引，而非聚集索引一个表可以存在多个。
- 聚集索引，索引中键值的逻辑顺序决定了表中相应行的物理顺序；非聚集索引，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。
- 索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。
- 聚集索引：物理存储按照索引排序；非聚集索引：物理存储不按照索引排序；

### 非聚簇索引一定会进行回表查询吗？

不一定，这里涉及到一个索引覆盖的问题，如果查询的数据在辅助索引上完全能获取到便不需要回表查询。例如有一张表存储着个人信息包括 id、name、age 等字段。假设聚簇索引是以 ID 为键值构建的索引，非聚簇索引是以 name 为键值构建的索引，`select id,name from user where name = 'zhangsan';`这个查询便不需要进行回表查询因为，通过非聚簇索引已经能全部检索出数据，这就是索引覆盖的情况。如果查询语句是这样，`select id,name,age from user where name = 'zhangsan';` 则需要进行回表查询，因为通过非聚簇索引不能检索出 age 的值。那应该如何解决那呢？只需要将索引覆盖即可，建立 age 和 name 的联合索引再使用`select id,name,age from user where name = 'zhangsan';`进行查询即可。

所以通过索引覆盖能解决非聚簇索引回表查询的问题。

### 索引的数据结构？

索引的数据结构主要有 B+ 树和哈希表，对应的索引分别为 B+ 树索引和哈希索引。（InnoDB 引擎默认的索引类型为 B+ 树索引）

- B+ 树索引：B+ 树的索引又可以分为主索引和辅助索引。其中主索引为聚簇索引，辅助索引为非聚簇索引。聚簇索引是以主键作为 B+ 树索引的键值所构成的 B+ 树索引，聚簇索引的叶子节点存储着完整的数据记录；非聚簇索引是以非主键的列作为 B+ 树索引的键值所构成的 B+ 树索引，非聚簇索引的叶子节点存储着主键值。所以使用非聚簇索引进行查询时，会先找到主键值，然后到根据聚簇索引找到主键对应的数据域。


- 哈希索引：哈希索引是基于哈希表实现的，对于每一行数据，存储引擎会对索引列通过哈希算法进行哈希计算得到哈希码，并且哈希算法要尽量保证不同的列值计算出的哈希码值是不同的，将哈希码的值作为哈希表的 key 值，将指向数据行的指针作为哈希表的 value 值。这样查找一个数据的时间复杂度就是 o(1)，一般多用于精确查找。

### Hash 索引和 B + 树区别是什么？

- B + 树可以进行范围查询，Hash 索引不能。
- B + 树支持联合索引的最左侧原则，Hash 索引不支持。
- B + 树支持 order by 排序，Hash 索引不支持。
- Hash 索引在等值查询上比 B + 树效率更高。
- B + 树使用 like 进行模糊查询的时候，like 后面（比如 % 开头）的话可以起到优化的作用，Hash 索引根本无法进行模糊查询。

因为两者数据结构上的差异导致它们的使用场景也不同，哈希索引一般多用于精确的等值查找，B+ 索引则多用于除了精确的等值查找外的其他查找。在大多数情况下，会选择使用B+树索引。

### 索引创建的注意事项

* 非空字段：应该指定列为 NOT NULL，除非你想存储 NULL。在 MySQL 中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。应该用 0、一个特殊的值或者一个空串代替空值；
* 取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过 count() 函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；
* 索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次 IO 操作获取的数据越大效率越高。

### 索引使用的注意事项

* 符合索引遵循前缀原则
* like 查询 % 不能再前，否则索引失效。如有需要，使用全文索引
* column is null 可以使用索引
* 如果 MySQL 估计使用索引比全表扫描慢，则放弃使用索引
* 如果 or 前的条件中列有索引，后面的没有，索引不会生效
* 列类型是字符串，查询时，一定要给值加引号，否则索引失效
* 确定 order by 和 group by 中只有一个表的列，这样才能使用索引。换句话说，当order by 中的字段出现在 where 条件中时，才会利用索引而不排序，更准确的说，order by 中的字段在执行计划中利用了索引时，不用排序操作
* 使用的索引列不能参与运算，否则失效

### 索引哪些情况会失效

- 查询条件包含 or，会导致索引失效。
- 隐式类型转换，会导致索引失效，例如 age 字段类型是 int，我们 where age = “1”，这样就会触发隐式类型转换。
- like 通配符会导致索引失效，注意：“ABC%” 不会失效，会走 range 索引，“%ABC” 索引会失效
- 联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。
- 对索引字段进行函数运算。
- 对索引列运算（如，+、-、*、/），索引失效。
- 索引字段上使用（!= 或者 < >，not in）时，会导致索引失效。
- 索引字段上使用 is null， is not null，可能导致索引失效。
- 相 join 的两个表的字符编码不同，不能命中索引，会导致笛卡尔积的循环计算
- mysql 估计使用全表扫描要比使用索引快，则不使用索引。

### 索引不适合哪些场景

- 数据量少的不适合加索引
- 更新比较频繁的也不适合加索引
- 离散性低的字段不适合加索引（如性别）

### 索引的使用场景有哪些？

- 对于中大型表建立索引非常有效，对于非常小的表，一般全部表扫描速度更快些。
- 对于超大型的表，建立和维护索引的代价也会变高，这时可以考虑分区技术。
- 如何表的增删改非常多，而查询需求非常少的话，那就没有必要建立索引了，因为维护索引也是需要代价的。
- 一般不会出现在where条件中的字段就没有必要建立索引了。
- 多个字段经常被查询的话可以考虑联合索引。
- 字段多且字段值没有重复的时候考虑唯一索引。
- 字段多且有重复的时候考虑普通索引。

### 索引的设计原则？

- 最适合索引的列是在where后面出现的列或者连接句子中指定的列，而不是出现在SELECT关键字后面的选择列表中的列。
- 索引列的基数越大，索引的效果越好，换句话说就是索引列的区分度越高，索引的效果越好。比如使用性别这种区分度很低的列作为索引，效果就会很差，因为列的基数最多也就是三种，大多不是男性就是女性。
- 尽量使用短索引，对于较长的字符串进行索引时应该指定一个较短的前缀长度，因为较小的索引涉及到的磁盘I/O较少，并且索引高速缓存中的块可以容纳更多的键值，会使得查询速度更快。
- 尽量利用最左前缀。
- 不要过度索引，每个索引都需要额外的物理空间，维护也需要花费时间，所以索引不是越多越好。

### 使用索引查询一定能提高查询的性能吗？

通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的 INSERT，DELETE，UPDATE 将为此多付出 4，5 次的磁盘 I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况：

* 基于一个范围的检索，一般查询返回结果集小于表中记录数的 30%
* 基于非唯一性索引的检索

### 为什么要用 B + 树，不用二叉树？

可以从几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数，为什么不是二叉树，为什么不是平衡二叉树，为什么不是 B 树，而偏偏是 B + 树呢？

**为什么不是一般二叉树？**

* 当数据量大时，树的高度会比较高（树的高度决定着它的 IO 操作次数，IO 操作耗时大），查询会比较慢。
* 每个磁盘块（节点 / 页）保存的数据太小（IO 本来是耗时操作，每次 IO 只能读取到一个关键字，显然不合适），没有很好的利用操作磁盘 IO 的数据交换特性，也没有利用好磁盘 IO 的预读能力（空间局部性原理），从而带来频繁的 IO 操作。

**为什么不是平衡二叉树呢？**

我们知道，在内存比在磁盘的数据，查询效率快得多。如果树这种数据结构作为索引，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，如果是 B 树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快啦。

**为什么不是 B 树而是 B + 树呢？**

* B+Tree 范围查找，定位 min 与 max 之后，中间叶子节点，就是结果集，不用中序回溯
* B+Tree 磁盘读写能力更强（叶子节点不保存真实数据，因此一个磁盘块能保存的关键字更多，因此每次加载的关键字越多）
* B+Tree 扫表和扫库能力更强（B-Tree 树需要扫描整颗树，B+Tree 树只需要扫描叶子节点）

### 什么是最左前缀原则、最左匹配原则？

顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where 子句中使用最频繁的一列放在最左边。

最左前缀匹配原则，非常重要的原则，MySQL 会一直向右匹配直到遇到范围查询 `(>、<、between、like)` 就停止匹配，比如 `a = 1 and b = 2 and c > 3 and d = 4` 如果建立 (a,b,c,d) 顺序的索引，d 是用不到索引的，如果建立 (a,b,d,c) 的索引则都可以用到，a,b,d 的顺序可以任意调整。

= 和 in 可以乱序，比如 a = 1 and b = 2 and c = 3 建立 (a,b,c) 索引可以任意顺序，MySQL 的查询优化器会帮你优化成索引可以识别的形式。

### 什么是前缀索引？

前缀索引是指对文本或者字符串的前几个字符建立索引，这样索引的长度更短，查询速度更快。

使用场景：前缀的区分度比较高的情况下。

建立前缀索引的方式

```
ALTER TABLE table_name ADD KEY(column_name(prefix_length));
```

这里面有个prefix_length参数很难确定，这个参数就是前缀长度的意思。通常可以使用以下方法进行确定，先计算全列的区分度

```
SELECT COUNT(DISTINCT column_name) / COUNT(*) FROM table_name;
```

然后在计算前缀长度为多少时和全列的区分度最相似。

```
SELECT COUNT(DISTINCT LEFT(column_name, prefix_length)) / COUNT(*) FROM table_name;
```

不断地调整prefix_length的值，直到和全列计算出区分度相近。

### 什么是最左匹配原则？

最左匹配原则：从最左边为起点开始连续匹配，遇到范围查询（<、>、between、like）会停止匹配。

例如建立索引 (a,b,c)，大家可以猜测以下几种情况是否用到了索引。

- 第一种

  ```
  select * from table_name where a = 1 and b = 2 and c = 3 
  select * from table_name where b = 2 and a = 1 and c = 3
  ```

  上面两次查询过程中所有值都用到了索引，where 后面字段调换不会影响查询结果，因为 MySQL 中的优化器会自动优化查询顺序。

- 第二种

  ```
  select * from table_name where a = 1
  select * from table_name where a = 1 and b = 2  
  select * from table_name where a = 1 and b = 2 and c = 3
  ```

  答案是三个查询语句都用到了索引，因为三个语句都是从最左开始匹配的。

- 第三种

  ```
  select * from table_name where b = 1 
  select * from table_name where b = 1 and c = 2 
  ```

  答案是这两个查询语句都没有用到索引，因为不是从最左边开始匹配的

- 第四种

  ```
  select * from table_name where a = 1 and c = 2 
  ```

  这个查询语句只有 a 列用到了索引，c 列没有用到索引，因为中间跳过了 b 列，不是从最左开始连续匹配的。

- 第五种

  ```
  select * from table_name where a = 1 and b < 3 and c < 1
  ```

  这个查询中只有 a 列和 b 列使用到了索引，而 c 列没有使用索引，因为根据最左匹配查询原则，遇到范围查询会停止。

- 第六种

  ```
  select * from table_name where a like 'ab%'; 
  select * from table_name where a like '%ab'
  select * from table_name where a like '%ab%'
  ```

  对于列为字符串的情况，只有前缀匹配可以使用索引，中缀匹配和后缀匹配只能进行全表扫描。

### 索引在什么情况下会失效？

在上面介绍了几种不符合最左匹配原则的情况会导致索引失效，除此之外，以下这几种情况也会导致索引失效。

- 条件中有 or，例如 `select * from table_name where a = 1 or b = 3`
- 在索引上进行计算会导致索引失效，例如 `select * from table_name where a + 1 = 2`
- 在索引的类型上进行数据类型的隐形转换，会导致索引失效，例如字符串一定要加引号，假设 `select * from table_name where a = '1'`会使用到索引，如果写成 `select * from table_name where a = 1`则会导致索引失效。
- 在索引中使用函数会导致索引失效，例如 `select * from table_name where abs(a) = 1`
- 在使用 like 查询时以 % 开头会导致索引失效
- 索引上使用 ！、=、<> 进行判断时会导致索引失效，例如 `select * from table_name where a != 1`
- 索引字段上使用 is null/is not null 判断时会导致索引失效，例如 `select * from table_name where a is null`

### 联合索引是什么？为什么需要注意联合索引中的顺序？

MySQL 可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。

具体原因为:

MySQL 使用索引时需要索引有序，假设现在建立了 "name，age，school" 的联合索引，那么索引的排序为：先按照 name 排序，如果 name 相同，则按照 age 排序，如果 age 的值也相等，则按照 school 进行排序。

当进行查询时，此时索引仅仅按照 name 严格有序，因此必须首先使用 name 字段进行等值查询，之后对于匹配到的列而言，其按照 age 字段严格有序，此时可以使用 age 字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。

## 事务

### 什么是事务？

数据库事务（transaction）是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。

### 事务的 ACID 特性？

- 原子性：原子性是指包含事务的操作要么全部执行成功，要么全部失败回滚。
- 一致性：一致性指事务在执行前后状态是一致的。
- 隔离性：一个事务所进行的修改在最终提交之前，对其他事务是不可见的。
- 持久性：数据一旦提交，其所作的修改将永久地保存到数据库中。

### 特性的实现思想

- 原子性：是使用 undo log 来实现的，如果事务执行过程中出错或者用户执行了 rollback，系统通过 undo log 日志返回事务开始的状态。
- 一致性：通过回滚、恢复，以及并发情况下的隔离性，从而实现一致性。
- 隔离性：通过锁以及 MVCC，使事务相互隔离开。
- 持久性：使用 redo log 来实现，只要 redo log 日志持久化了，当系统崩溃，即可通过 redo log 把数据恢复。

### 事务并发一致性问题

- 脏读：事务A更新了数据，但还没有提交，这时事务B读取到事务A更新后的数据，然后事务A回滚了，事务B读取到的数据就成为脏数据了。
- 不可重复读：事务A对数据进行多次读取，事务B在事务A多次读取的过程中执行了更新操作并提交了，导致事务A多次读取到的数据并不一致。
- 幻读：事务A在读取数据后，事务B向事务A读取的数据中插入了几条数据，事务A再次读取数据时发现多了几条数据，和之前读取的数据不一致。
- 丢失修改：事务A和事务B都对同一个数据进行修改，事务A先修改，事务B随后修改，事务B的修改覆盖了事务A的修改。

### 事务的隔离级别

* 读未提交：一个事务还没提交时，它做的变更就能被别的事务看到。
* 读提交：一个事务提交之后，它做的变更才会被其他事务看到。
* 可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。（InnoDB 默认的隔离级别）
* 串行化：顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

数据库的隔离级别分别可以解决数据库的脏读、不可重复读、幻读等问题。

| 隔离级别 |  脏读  | 不可重复读 |  幻读  |
| :------: | :----: | :--------: | :----: |
| 读未提交 |  允许  |    允许    |  允许  |
|  读提交  | 不允许 |    允许    |  允许  |
| 可重复读 | 不允许 |   不允许   |  允许  |
|  串行化  | 不允许 |   不允许   | 不允许 |

### 隔离级别是如何实现的？

事务的隔离机制主要是依靠锁机制和 MVCC（多版本并发控制）实现的，提交读和可重复读可以通过 MVCC 实现，串行化可以通过锁机制实现。

**什么是 MVCC？**

MVCC（multiple version concurrent control）是一种控制并发的方法，主要用来提高数据库的并发性能。

在了解 MVCC 时应该先了解当前读和快照读。

- 当前读：读取的是数据库的最新版本，并且在读取时要保证其他事务不会修改当前记录，所以会对读取的记录加锁。
- 快照读：不加锁读取操作即为快照读，使用MVCC来读取快照中的数据，避免加锁带来的性能损耗。

可以看到 MVCC 的作用就是在不加锁的情况下，解决数据库读写冲突问题，并且解决脏读、幻读、不可重复读等问题，但是不能解决丢失修改问题。

**MVCC的实现原理**

- 版本号

  系统版本号：是一个自增的 ID，每开启一个事务，系统版本号都会递增。

  事务版本号：事务版本号就是事务开始时的系统版本号，可以通过事务版本号的大小判断事务的时间顺序。

- 行记录隐藏的列

  DB_ROW_ID：所需空间 6 byte，隐含的自增 ID，用来生成聚簇索引，如果数据表没有指定聚簇索引，InnoDB 会利用这个隐藏 ID 创建聚簇索引。

  DB_TRX_ID：所需空间 6 byte，最近修改的事务 ID，记录创建这条记录或最后一次修改这条记录的事务 ID。

  DB_ROLL_PTR：所需空间 7 byte，回滚指针，指向这条记录的上一个版本。

- undo 日志

  MVCC 做使用到的快照会存储在Undo日志中，该日志通过回滚指针将一个一个数据行的所有快照连接起来。


### 什么是数据库的锁？

当数据库有并发事务的时候，保证数据访问顺序的机制称为锁机制。

### 数据库的锁与隔离级别的关系？

| 隔离级别 |                 实现方式                 |
| :------: | :--------------------------------------: |
| 读未提交 |       总是读取最新的数据，无需加锁       |
|  读提交  | 读取数据时加共享锁，读取数据后释放共享锁 |
| 可重复读 | 读取数据时加共享锁，事务结束后释放共享锁 |
|  串行化  | 锁定整个范围的键，一直持有锁直到事务结束 |

### 数据库锁的类型有哪些？

按照锁的粒度可以将 MySQ L锁分为三种：

| MySQL锁类别 | 资源开销 | 加锁速度 | 是否会出现死锁 | 锁的粒度 | 并发度 |
| :---------: | :------: | :------: | :------------: | :------: | :----: |
|   表级锁    |    小    |    快    |      不会      |    大    |   低   |
|   行级锁    |    大    |    慢    |       会       |    小    |   高   |
|   页面锁    |   一般   |   一般   |      不会      |   一般   |  一般  |

MyISAM 默认采用表级锁，InnoDB 默认采用行级锁。

从锁的类别上区别可以分为共享锁和排他锁

- 共享锁：共享锁又称读锁，简写为 S 锁，一个事务对一个数据对象加了 S 锁，可以对这个数据对象进行读取操作，但不能进行更新操作。并且在加锁期间其他事务只能对这个数据对象加 S 锁，不能加 X 锁。
- 排他锁：排他锁又称为写锁，简写为 X 锁，一个事务对一个数据对象加了 X 锁，可以对这个对象进行读取和更新操作，加锁期间，其他事务不能对该数据对象进行加 X 锁或 S 锁。

### 什么是数据库的乐观锁和悲观锁？

乐观锁

* 系统假设数据的更新在大多数时候是不会产生冲突的，所以数据库只在更新操作提交的时候对数据检测冲突，如果存在冲突，则数据更新失败。
* 乐观锁实现方式：一般通过版本号和CAS算法实现。

悲观锁

* 假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。通俗讲就是每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁。
* 悲观锁的实现方式：通过数据库的锁机制实现，对查询语句添加 for updata。

### 什么是死锁？如何避免？

死锁是指两个或者两个以上进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。在 MySQL 中，MyISAM 是一次获得所需的全部锁，要么全部满足，要么等待，所以不会出现死锁。在 InnoDB 存储引擎中，除了单个 SQL 组成的事务外，锁都是逐步获得的，所以存在死锁问题。

如何避免 MySQL 发生死锁或锁冲突：

- 如果不同的程序并发存取多个表，尽量以相同的顺序访问表。
- 在程序以批量方式处理数据的时候，如果已经对数据排序，尽量保证每个线程按照固定的顺序来处理记录。
- 在事务中，如果需要更新记录，应直接申请足够级别的排他锁，而不应该先申请共享锁，更新时在申请排他锁，因为在当前用户申请排他锁时，其他事务可能已经获得了相同记录的共享锁，从而造成锁冲突或者死锁。
- 尽量使用较低的隔离级别
- 尽量使用索引访问数据，使加锁更加准确，从而减少锁冲突的机会
- 合理选择事务的大小，小事务发生锁冲突的概率更低
- 尽量用相等的条件访问数据，可以避免Next-Key锁对并发插入的影响。
- 不要申请超过实际需要的锁级别，查询时尽量不要显示加锁
- 对于一些特定的事务，可以表锁来提高处理速度或减少死锁的概率。

排查死锁的步骤：

- 查看死锁日志 show engine innodb status;
- 找出死锁 SQL
- 分析 SQL 加锁情况
- 模拟死锁案发
- 分析死锁日志
- 分析死锁结果

## 实践

### 百万级别或以上的数据如何删除

关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件，所以当我们对数据的增加、修改、删除都会产生额外的对索引文件的操作,这些操作需要消耗额外的 IO，会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询 MySQL 官方手册得知删除数据的速度和创建的索引数量是成正比的。

* 所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）
* 然后删除其中无用数据（此过程需要不到两分钟）
* 删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。
* 与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。

### 谈谈 SQL 优化的经验

- 加索引
- 避免返回不必要的数据
- 适当分批量进行
- 优化 SQL 结构
- 主从架构，提升读性能
- 分库分表

---

* 查询语句无论是使用哪种判断条件等于、小于、大于，WHERE 左侧的条件，查询字段不要使用函数或者表达式
* 使用 EXPLAIN 命令优化你的 SELECT 查询，对于复杂、效率低的 sql 语句，我们通常是使用 explainsql 来分析这条 sql 语句，这样方便我们分析，进行优化。
* 当你的 SELECT 查询语句只需要使用一条记录时，要使用 LIMIT 1。不要直接使用 SELECT*，而应该使用具体需要查询的表字段，因为使用 EXPLAIN 进行分析时，SELECT"使用的是全表扫描，也就是 type =all 。
* 为每一张表设置一个 ID 属性。
* 避免在 MHERE 字句中对字段进行 NULL 
* 判断避免在 WHERE 中使用!或>操作符
* 使用 BETWEEN AND 替代 IN
* 为搜索字段创建索引
* 选择正确的存储引擎，InnoDB、MyISAM、MEMORY 等
* 使用 LIKE%abc% 不会走索引，而使用 LIKE abc% 会走索引。
* 对于枚举类型的字段(即有固定罗列值的字段)，建议使用 ENUM 而不是 VARCHAR，如性别、星期、类型、类别等。
* 拆分大的 DELETE 或 INSERT 语句
* 选择合适的字段类型，选择标准是尽可能小、尽可能定长、尽可能使用整数。
* 字段设计尽可能使用 NOT NULL
* 进行水平切割或者垂直分割

---

（1）Where子句中：where表之间的连接必须写在其他Where条件之前，那些可以过滤掉最大数量记录的条件必须写在Where子句的末尾.HAVING最后。

（2）用EXISTS替代IN、用NOT EXISTS替代NOT IN。

（3） 避免在索引列上使用计算

（4）避免在索引列上使用IS NULL和IS NOT NULL

（5）对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。　　

（6）应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描

（7）应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描

### 主从复制，读写分离

主从复制，是用来建立一个和主数据库完全一样的数据库环境，称为从数据库；

**主从复制的原理：**

1. 数据库有个 bin-log 二进制文件，记录了所有的 sql 语句。
2. 只需要把主数据库的 bin-log 文件中的 sql 语句复制。
3. 让其从数据的 relay-log 重做日志文件中在执行一次这些 sql 语句即可。

**主从复制的作用：**

* 做数据的热备份，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。
* 架构的扩展。业务量越来越大，I/O 访问频率过高，单机无法满足，此时做多库的存储，降低磁盘 I/O 访问频率，提高单机的 I/O 性能
* 主从复制是读写分离的基础，使数据库能制成更大的并发。例如子报表中，由于部署报表的 sql 语句十分慢，导致锁表，影响前台的服务。如果前台服务使用 master，报表使用 slave，那么报表 sql 将不会造成前台所，保证了前台的访问速度。

**主从复制的几种方式：**

* 同步复制：所谓的同步复制，意思是master的变化，必须等待slave-1,slave-2,...,slave-n完成后才能返回。
* 异步复制：如同 AJAX 请求一样。master 只需要完成自己的数据库操作即可。至于 slaves 是否收到二进制日志，是否完成操作，不用关心。MYSQL 的默认设置。
* 半同步复制：master 只保证 slaves 中的一个操作成功，就返回，其他 slave不管。这个功能，是由 google 为 MYSQL 引入的。

**关于读写分离：**

在完成主从复制时，由于 slave 是需要同步 master 的。所以对于 insert/delete/update 这些更新数据库的操作，应该在 master 中完成。而 select 的查询操作，则落下到 slave 中。

### 分库分表的设计

分库分表方案，分库分表中间件，分库分表可能遇到的问题

**分库分表方案**

- 水平分库：以字段为依据，按照一定策略（hash、range 等），将一个库中的数据拆分到多个库中。
- 水平分表：以字段为依据，按照一定策略（hash、range 等），将一个表中的数据拆分到多个表中。
- 垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。
- 垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。

**分库分表可能遇到的问题**

- 事务问题：需要用分布式事务啦
- 跨节点 Join 的问题：解决这一问题可以分两次查询实现
- 跨节点的 count,order by,group by 以及聚合函数问题：分别在各个节点上得到结果后在应用程序端进行合并。
- 数据迁移，容量规划，扩容等问题
- ID 问题：数据库被切分后，不能再依赖数据库自身的主键生成机制啦，最简单可以考虑 UUID
- 跨分片的排序分页问题（后台加大 pagesize 处理？）

### limit 1000000 加载很慢的话，你是怎么解决的呢？

方案一：如果 id 是连续的，可以这样，返回上次查询的最大记录 (偏移量)，再往下 limit

```sql
select id, name from employee where id > 1000000 limit 10
```

方案二：在业务允许的情况下限制页数： 建议跟业务讨论，有没有必要查这么后的分页啦。因为绝大多数用户都不会往后翻太多页。

方案三：order by + 索引（id 为索引）

```php
select id，name from employee order by id  limit 1000000，10
SELECT a.* FROM employee a, (select id from employee where 条件 LIMIT 1000000,10 ) b where a.id = b.id
```

方案四：利用延迟关联或者子查询优化超多分页场景。（先快速定位需要获取的 id 段，然后再关联）

### 如何选择合适的分布式主键方案呢？

- 数据库自增长序列或字段。
- UUID
- 雪花算法
- Redis 生成 ID
- 利用 zookeeper 生成唯一 ID

### MySQL 的主从延迟，你怎么解决？

**主从复制分了五个步骤进行**

- 步骤一：主库的更新事件 (update、insert、delete) 被写到 binlog
- 步骤二：从库发起连接，连接到主库。
- 步骤三：此时主库创建一个 binlog dump thread，把 binlog 的内容发送到从库。
- 步骤四：从库启动之后，创建一个 I/O 线程，读取主库传过来的 binlog 内容并写入到 relay log
- 步骤五：还会创建一个 SQL 线程，从 relay log 里面读取内容，从 Exec_Master_Log_Pos 位置开始执行读取到的更新事件，将更新内容写入到 slave 的 db

**主从同步延迟的原因**

一个服务器开放Ｎ个链接给客户端来连接的，这样有会有大并发的更新操作，但是从服务器的里面读取 binlog 的线程仅有一个，当某个 SQL 在从服务器上执行的时间稍长 或者由于某个 SQL 要进行锁表就会导致，主服务器的 SQL 大量积压，未被同步到从服务器里。这就导致了主从不一致， 也就是主从延迟。

**主从同步延迟的解决办法**

* 方案一：忽略（如果业务能够接受，别把系统架构搞得太复杂。）
* 方案二：强制读主（这是很常见的微服务架构，可以避免数据库主从一致性问题。）
* 方案三：选择性读主（只有这一段时间，可能读到从库脏数据的读请求读主，平时读从。）

可以参考沈剑老师的文章：[数据库主从不一致怎么解决？](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961330&idx=1&sn=4bdbada3b26d4fc2fc505f7a0f2ad7c4&chksm=bd2d022e8a5a8b38e59f0dfffba7ca407fe8711644b3794832572dd822c665205bb820cdddf7&scene=21#wechat_redirect)

### 大表数据查询如何进行优化？

- 索引优化
- SQL 语句优化
- 水平拆分
- 垂直拆分
- 建立中间表
- 使用缓存技术
- 固定长度的表访问起来更快
- 越小的列访问越快

### 如何优化查询过程中的数据访问？

从减少数据访问方面考虑：

- 正确使用索引，尽量做到索引覆盖
- 优化SQL执行计划

从返回更少的数据方面考虑：

- 数据分页处理
- 只返回需要的字段

从减少服务器CPU开销方面考虑：

- 合理使用排序
- 减少比较的操作
- 复杂运算在客户端处理

从增加资源方面考虑：

- 客户端多进程并行访问
- 数据库并行处理

### 如何优化长难的查询语句？

- 将一个大的查询分解为多个小的查询
- 分解关联查询，使缓存的效率更高

### 如何优化 LIMIT 分页？

- 在LIMIT偏移量较大的时候，查询效率会变低，可以记录每次取出的最大 ID，下次查询时可以利用 ID 进行查询
- 建立复合索引

### 如何优化 UNION 查询

如果不需要对结果集进行去重或者排序建议使用UNION ALL，会好一些。

### 如何优化 WHERE 子句

- 不要在where子句中使用!=和<>进行不等于判断，这样会导致放弃索引进行全表扫描。
- 不要在where子句中使用null或空值判断，尽量设置字段为not null。
- 尽量使用union all代替or
- 在where和order by涉及的列建立索引
- 尽量减少使用in或者not in，会进行全表扫描
- 在where子句中使用参数会导致全表扫描
- 避免在where子句中对字段及进行表达式或者函数操作会导致存储引擎放弃索引进而全表扫描

### SQL 语句执行的很慢原因是什么？

- 如果 SQL 语句只是偶尔执行很慢，可能是执行的时候遇到了锁，也可能是 redo log 日志写满了，要将 redo log 中的数据同步到磁盘中去。
- 如果 SQL 语句一直都很慢，可能是字段上没有索引或者字段有索引但是没用上索引。

### 大表如何优化？

- 限定数据的范围：避免不带任何限制数据范围条件的查询语句。
- 读写分离：主库负责写，从库负责读。
- 垂直分表：将一个表按照字段分成多个表，每个表存储其中一部分字段。
- 水平分表：在同一个数据库内，把一个表的数据按照一定规则拆分到多个表中。
- 对单表进行优化：对表中的字段、索引、查询SQL进行优化。
- 添加缓存

