---
layout: post
---

## PHP 的垃圾回收机制

PHP 可以自动进行内存管理，清除不需要的对象，主要是使用了引用计数 (reference counting) GC 机制。每个定义的变量是存在一个叫 zval 的结构体中，zval 中除了存储变量类型和值外，还有 is_ref 和 refcount 字段。is_ref 字段表示变量是否属于引用集合(reference set)。refcount 字段是引用计数，标识此 zval 被多少个变量引用，为 0 时会被销毁，释放其所占的内存空间。如果 refcount 减 1 之后大于 0，它就会进入垃圾缓冲区。当缓冲区达到最大值后，回收算法会循环遍历 zval，判断其是否为垃圾，并进行释放处理。

参考 [https://www.php.net/manual/zh/features.gc.refcounting-basics.php](https://www.php.net/manual/zh/features.gc.refcounting-basics.php)

## PHP 运行机制与原理

PHP动态语言执行过程：拿到一段代码后，经过词法解析、语法解析等阶段后，源程序会被翻译成一个个指令（opcodes），然后 Zend 虚拟机顺次执行这些指令完成操作。PHP 本身是用 C 实现的，因此最终调用的也是 C 的函数，实际上，我们可以把 PHP 看做一个 C 开发的软件。

PHP的四层体系：

* Zend 引擎：Zend 整体用纯 C 实现，是 PHP 的内核部分，它将 PHP 代码翻译（词法、语法解析等一系列编译过程）为可执行 opcode 处理，并实现相应的处理方法，实现了基本的数据结构（如 hashtable、oo）、内存分配及管理、提供了相应的 api 方法供外部调用，是一切的核心，所有的外围功能均围绕 Zend 实现。
* Extensions：围绕着 Zend 引擎，extensions 通过组件式的方式提供各种基础服务，我们常见的各种内置函数（如 array 系列）、标准库等都是通过 extension 来实现，用户也可以根据需要实现自己的 extension 以达到功能扩展、性能优化等目的（如贴吧正在使用的 PHP 中间层、富文本解析就是 extension 的典型应用）。
* Sapi：Sapi 全称是 Server Application Programming Interface，也就是服务端应用编程接口，Sapi 通过一系列钩子函数，使得 PHP 可以和外围交互数据，这是 PHP 非常优雅和成功的一个设计，通过 sapi 成功的将 PHP 本身和上层应用解耦隔离，PHP 可以不再考虑如何针对不同应用进行兼容，而应用本身也可以针对自己的特点实现不同的处理方式。
* Application：这就是我们平时编写的 PHP 程序，通过不同的 sapi 方式得到各种各样的应用模式，如通过 webserver 实现 web 应用、在命令行下以脚本方式运行等等。

如果 PHP 是一辆车，那么车的框架就是 PHP 本身，Zend 是车的引擎（发动机），Ext 下面的各种组件就是车的轮子，Sapi 可以看做是公路，车可以跑在不同类型的公路上，而一次 PHP 程序的执行就是汽车跑在公路上。因此，我们需要：性能优异的引擎+合适的车轮+正确的跑道。

## PHP 的五大运行模式

* CGI（通用网关接口/ Common Gateway Interface）
* FastCGI（常驻型CGI / Long-Live CGI）
* CLI（命令行运行 / Command Line Interface）
* LoadModule【Apache独有】
* ISAPI（Internet Server Application Program Interface）【IIS独有】

## CGI、FastCGI、php-cgi、php-fpm 是什么？

CGI：CGI（Common Gateway Interface）全称是“通用网关接口”，是一种让客户端（浏览器）与 Web 服务器（Apache / Nginx 等）程序进行通信（数据传输）的协议。

FastCGI：FastCGI（Fast Common Gateway Interface）全称是 “快速通用网关接口”，是通用网关接口（CGI）的增强版本，由 CGI 发展改进而来，主要用来提高 CGI 程序性能，类似于 CGI，FastCGI 也是一种让交互程序与 Web 服务器通信的协议。

php-cgi：php-cgi 是 PHP 自带的 FastCGI 管理器。他自己本身只能解析请求，返回结果，不会管理进程。

php-fpm：FastCGI 是一个方案或者协议，php-fpm 就是 FastCGI 的后端实现，也就是说，进程分配和管理是 FPM 来做的。官方对 FPM 的解释：Fastcgi Process Manager（Fastcgi 进程管理器）php-fpm 的管理对象是 php-cgi，他负责管理一个进程池，来处理来自 Web 服务器的请求。

对于 php.ini 文件的修改，php-cgi 进程是没办法平滑重启的，有了 php-fpm 后，就把平滑重启成为了一种可能，php-fpm 对此的处理机制是新的 worker 用新的配置，已经存在的 worker 处理完手上的活就可以歇着了，通过这种机制来平滑过度的。

## FastCGI 为什么比 CGI 更快？

CGI 程序的性能问题在哪呢？“PHP 解析器会解析 php.ini 文件，初始化执行环境"，就是这里了。标准的 CGI 对每个请求都会执行这些步骤，所以处理的时间会比较长。

FastCGI 会先启一个 master，解析配置文件，初始化执行环境，然后再启动多个 worker。当请求过来时，master 会传递给一个 worker，然后立即可以接受下一个请求。这样就避免了重复劳动，效率自然提高。而且当 worker 不够用时，master 可以根据配置预先启动几个 worker 等着；当然空闲 worker 太多时，也会停掉一些，这样就提高了性能，也节约了资源。这就是 Fastcgi 的对进程的管理。

## php-fpm，FastCGI，Nginx 之间是什么关系？

客户端（浏览器）发起动态请求（请求 php 文件）到 Web 服务器（Apache / Nginx 等），Web 服务器并不能直接处理动态请求，然后通过 CGI/FastCGI 协议交给 PHP 解析器（php-fpm 管理 php-cgi）进行处理，PHP 解析器处理完成后把数据又通过 CGI/FastCGI 协议返回给 Web 服务器，最后 Web 服务器返回给客户端。 

## Session 与 Cookie 的区别和关系

区别：

|                  | Session                                                      | Cookie                                                       |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 存放位置         | 保存在服务器                                                 | 保存在客户端                                                 |
| 存放形式         | 以对象的形式保存在服务器                                     | 以字符串的形式保存在客户端                                   |
| 用途             | 适合做客户的身份验证                                         | 适合做保存用户的个人设置、爱好等                             |
| 路径             | Session 不能区分路径，同一个用户在访问一个网站期间，所有的 Session 在任何一个地方都可以访问到 | Cookie 中如果设置了路径参数，那么同一个网站中不同路径下的 Cookie 互相是访问不到的 |
| 安全性           | 考虑到安全应当使用 Session                                   | Cookie 不是很安全，别人可以分析存放在本地的 Cookie 并进行 Cookie 欺骗 |
| 大小以及数量限制 | 一般认为 Session 没有大小和数量限制                          | 每个域名所包含的 Cookie 数：IE7/8，FireFox:50 个，Opera30 个；Cookie 总大小：Firefox 和 Safari 允许 cookie 多达 4097 个字节，Opera 允许 cookie 多达 4096 个字节，InternetExplorer 允许 cookie 多达 4095 个字节 |

关系：

Session 需要借助 Cookie 才能正常工作。如果客户端完全禁止 Cookie，Session 将失效！因为 Session 是由应用服务器维持的一个服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的 SessionID，用该 SessionID 为标识符来存取服务器端的 Session 存储空间。而 SessionID 这一数据则是保存到客户端，用 Cookie 保存的，用户提交页面时，会将这一 SessionID 提交到服务器端，来存取 Session 数据。这一过程，是不用开发人员干预的。所以一旦客户端禁用 Cookie，那么 Session 也会失效。

## 长连接、短连接的区别和使用

区别：

* 长连接：client 方与 server 方先建立连接，连接建立后不断开，然后再进行报文发送和接收。这种方式下由于通讯连接一直存在。此种方式常用于 P2P 通信。
* 短连接：Client 方与 server 每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此方式常用于一点对多点通讯。C/S 通信。

使用：

* 长连接：长连接多用于操作频繁，点对点的通讯，而且连接数不能太多的情况。每个 TCP 连接的建立都需要三次握手，每个 TCP 连接的断开要四次握手。如果每次操作都要建立连接然后再操作的话处理速度会降低，所以每次操作下次操作时直接发送数据就可以了，不用再建立 TCP 连接。例如：数据库的连接用长连接，如果用短连接频繁的通信会造成 socket 错误，频繁的 socket 创建也是对资源的浪 费。
* 短连接：web 网站的 http 服务一般都用短连接。因为长连接对于服务器来说要耗费一定的资源。像 web 网站这么频繁的成千上万甚至上亿客户端的连接用短连接更省一些资源。试想如果都用长连接，而且同时用成千上万的用户，每个用户都占有一个连接的话，可想而知服务器的压力有多大。所以并发量大，但是每个用户又不需频繁操作的情况下需要短连接。

## 常见的 web 攻击方式

|              | 描述                                                         | 防范                                                         |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| XSS 攻击     | XSS（Cross Site Scripting）跨站脚本攻击，为了不与层叠样式表（CSS）混淆，故将跨站脚本攻击缩写为 XSS。原理即在网页中嵌入恶意脚本，当用户打开网页时，恶意脚本便开始在用户浏览器上执行，以盗取客户端cookie、用户名、密码，甚至下载木马程式，危害可想而知。 | 之所以会发生 XSS 攻击，是因为用户输入的数据变成了代码， 因此需要对用户输入的数据进行 HTML 转义处理，将输出的 “尖括号”、“单引号”、“引号” 之类的特色符号进行转义。 |
| CSRF 攻击    | CSRF攻击的全称跨站请求伪造（Cross Site Request Forgery），通过盗用用户的身份信息，以你的名义向第三方网站发起恶意请求，若转账、盗取账号、发信息、邮件。<br />所以CSRF攻击一般场景是：<br />1、用户登录受信站点A，生成本地cookie； <br />2、用户没有退出站点A，访问了恶意站点B。 | 1、将 Cookie 设置为 HttpOnly<br/>2、增加 token<br/>3、通过 Referer 识别<br/> |
| SQL 注入攻击 | SQL 注入攻击就是把 SQL 命令伪装成正常的http请求参数，传递到服务端，欺骗服务器最终执行恶意的 SQL 命令，达到入侵目的。 | 1、使用预编译语句<br />2、使用 ORM 框架                      |
| 文件上传漏洞 | 倘若 web 网站没有对文件类型进行严格的校验，导致可执行文件上传到了服务器，恶意程序就会执行。 | 为了避免恶意文件上传，需要对上传文件类型进行白名单校验，并限制文件大小，上传文件进行重命名。有关文件类型的校验，需要去了解下魔数（magic number）这个概念，这里不做引伸。 |
| DDoS 攻击    | DDoS（Distributed Denial Of Service）攻击即分布式服务攻击，借助公共网络，将数量庞大的计算器设备（肉鸡）联合起来，对一个或多个目标发动攻击，从而达到瘫痪目标主机的目的。 | 1、采用高性能的网络设备<br/>2、尽量避免NAT的使用<br/>3、充足的网络带宽保证<br/>4、升级主机服务器硬件<br/>5、把网站做成静态页面或者伪静态<br/>6、增强操作系统的TCP/IP栈<br/>7、安装专业抗DDOS防火墙<br/>8、HTTP 请求的拦截<br/>9、部署CDN |

## PHP 做好防盗链的基本思想

**什么是盗链？**

盗链是指服务提供商自己不提供服务的内容，通过技术手段绕过其它有利益的最终用户界面 (如广告)，直接在自己的网站上向最终用户提供其它服务提供商的服务内容，骗取最终用户的浏览和点击率。受益者不提供资源或提供很少的资源，而真正的服务提供商却得不到任何的收益。

网站盗链会大量消耗被盗链网站的带宽，而真正的点击率也许会很小，严重损害了被盗链网站的利益。 

**如何做防盗链？**

* 不定期更名文件或者目录
* 限制引用页：原理是，服务器获取用户提交信息的网站地址，然后和真正的服务端的地址相比较， 如果一致则表明是站内提交，或者为自己信任的站点提交，否则视为盗链。实现时可以使用 HTTP_REFERER1 和 htaccess 文件 (需要启用 mod_Rewrite)，结合正则表达式去匹配用户的每一个访问请求。
* 文件伪装：文件伪装是目前用得最多的一种反盗链技术，一般会结合服务器端动态脚本 (PHP/JSP/ASP)。实际上用户请求的文件地址，只是一个经过伪装的脚本文件，这个脚本文件会对用户的请求作认证，一般会检查 Session，Cookie 或 HTTP_REFERER 作为判断是否为盗链的依据。而真实的文件实际隐藏在用户不能够访问的地方，只有用户通过验证以后才会返回给用户
* 加密认证：这种反盗链方式，先从客户端获取用户信息，然后根据这个信息和用户请求的文件名 字一起加密成字符串 (Session ID) 作为身份验证。只有当认证成功以后，服务端才会把用户需要的文件传送给客户。一般我们会把加密的 Session ID 作为 URL 参数的一部分传递给服务器，由于这个 Session ID 和用户的信息挂钩，所以别人就算是盗取了链接，该 Session ID 也无法通过身份认证，从而达到反盗链的目的。这种方式对于分布式盗链非常有效。
* 随机附加码：每次，在页面里生成一个附加码，并存在数据库里，和对应的图片相关，访问图片时和此附加码对比，相同则输出图片，否则输出 404 图片
* 加入水印

## get 与 post 的区别

* GET 在浏览器回退时是无害的，而 POST 会再次提交请求。
* GET 产生的URL地址可以被 Bookmark，而 POST 不可以。
* GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。
* GET 请求只能进行 url 编码，而 POST 支持多种编码方式。
* GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。
* GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有。
* 对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。
* GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。
* GET 参数通过 URL 传递， POST 放在 Request body 中。
* GET 产生一个 TCP 数据包， POST 产生两个 TCP 数据包

## require 与 include 区别

* require 是无条件包含也就是如果一个流程里加入 require，无论条件成立与否都会先执行 require
* include 有返回值，而 require 没有，可能因为如此 require 的速度比 include 快
* 包含文件不存在或者语法错误的时候 require 是致命的错误终止执行，include 只是会产生一个 warning
* require 在运行前载入，include 在运行时载入

## Laravel 框架有哪些特点？

Laravel 框架最大的特点和优秀之处就是集合了 php 比较新的特点，以及各种各样的设计模式，Ioc模式，依赖注入等。

**新的特点：**

- 强大的 rest router：用简单的回调函数就可以调用，快速绑定 controller 和 router
- artisan：命令行工具,很多手动的工作都自动化
- 可继承的模板，简化 view 的开发和管理
- blade 模板：渲染速度更快
- ORM 操作数据库
- migration：管理数据库和版本控制
- 测试功能也很强大
- composer 也是亮点
- Laravel 框架引入了门面，依赖注入，Ioc模式，以及各种各样的设计模式等。

**架构模式：**

laravel框架是使用了服务组件化的开发模式，由多个服务提供者构成了组件，再由多个组件提供不同的服务，然后是多个服务构成了项目。

服务提供者是应用配置的核心，是通过 register方法中绑定服务到服务容器的。

**设计模式：**

Laravel 框架使用了大量设计模式，使模块之间耦合度很低，服务容器可以方便的扩展框架功能以及编写测试。

* ORM - 对象关系映射模式
* 依赖注入与 IOC 容器 - 策略模式
* 监听与触发 - 观察者模式
* 门面模式 - 静态代理

**特性方面：**

能快速开发出功能，自带各种方便的服务，比如数据验证、队列、缓存、数据迁移、测试、artisan 命令行等等，还有强大的 ORM，artisan 强大的命令行工具，实现自动化。

## 简述高并发网站解决方案

* 前端优化
  * 减少 HTTP 请求
  * CND 加速
  * 压缩 CSS、JS 等文件
  * 建立独立图片服务器
* 后端优化
  * 页面静态化
  * 并发处理（异步 / 多线程）
  * 队列处理
* 数据库优化
  * 数据库缓存（Memcachaed / Redis）
  * 读写分离
  * 分库分表分区
* 服务器优化
  * 负载均衡
  * 反向代理

